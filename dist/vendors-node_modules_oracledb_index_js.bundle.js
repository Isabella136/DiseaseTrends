/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkdt"] = self["webpackChunkdt"] || []).push([["vendors-node_modules_oracledb_index_js"],{

/***/ "./node_modules/oracledb/index.js":
/*!****************************************!*\
  !*** ./node_modules/oracledb/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/oracledb.js */ \"./node_modules/oracledb/lib/oracledb.js\");\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/index.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/aqDeqOptions.js":
/*!***************************************************!*\
  !*** ./node_modules/oracledb/lib/aqDeqOptions.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright (c) 2019, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nclass AqDeqOptions {\n\n  _extend(oracledb) { //eslint-disable-line\n  }\n\n}\n\nmodule.exports = AqDeqOptions;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/aqDeqOptions.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/aqEnqOptions.js":
/*!***************************************************!*\
  !*** ./node_modules/oracledb/lib/aqEnqOptions.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright (c) 2019, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nclass AqEnqOptions {\n\n  _extend(oracledb) { //eslint-disable-line\n  }\n\n}\n\nmodule.exports = AqEnqOptions;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/aqEnqOptions.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/aqMessage.js":
/*!************************************************!*\
  !*** ./node_modules/oracledb/lib/aqMessage.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright (c) 2019, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nclass AqMessage {\n\n  _extend(oracledb) { //eslint-disable-line\n  }\n\n}\n\nmodule.exports = AqMessage;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/aqMessage.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/aqQueue.js":
/*!**********************************************!*\
  !*** ./node_modules/oracledb/lib/aqQueue.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2019, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\n\n//-----------------------------------------------------------------------------\n// deqOne()\n//   Returns a single message from the queue, if one is available.\n//-----------------------------------------------------------------------------\nasync function deqOne() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._deqOne();\n}\n\n\n//-----------------------------------------------------------------------------\n// deqMany()\n//   Returns an array of messages from the queue, up to the maximum specified,\n// if any are available.\n//----------------------------------------------------------------------------\nasync function deqMany(maxMessages) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(typeof maxMessages === 'number', 'NJS-005', 1);\n  return await this._deqMany(maxMessages);\n}\n\n\n//-----------------------------------------------------------------------------\n// enqOne()\n//   Enqueues a single message into the queue.\n//-----------------------------------------------------------------------------\nasync function enqOne(message) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(typeof message === 'object' || typeof message === 'string',\n    'NJS-005', 1);\n  return await this._enqOne(message);\n}\n\n\n//-----------------------------------------------------------------------------\n// enqMany()\n//   Enqueues multiple messages into the queue at the same time, avoiding\n// multiple round-trips.\n//----------------------------------------------------------------------------\nasync function enqMany(messages) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(Array.isArray(messages), 'NJS-005', 1);\n  return await this._enqMany(messages);\n}\n\n\nclass AqQueue {\n\n  _extend() {\n    this.deqOne = nodbUtil.callbackify(nodbUtil.serialize(deqOne));\n    this.deqMany = nodbUtil.callbackify(nodbUtil.serialize(deqMany));\n    this.enqOne = nodbUtil.callbackify(nodbUtil.serialize(enqOne));\n    this.enqMany = nodbUtil.callbackify(nodbUtil.serialize(enqMany));\n  }\n\n  _getConnection() {\n    return this._connection;\n  }\n\n}\n\nmodule.exports = AqQueue;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/aqQueue.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/connection.js":
/*!*************************************************!*\
  !*** ./node_modules/oracledb/lib/connection.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n// Copyright (c) 2016, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst BaseDbObject = __webpack_require__(/*! ./dbObject.js */ \"./node_modules/oracledb/lib/dbObject.js\");\nconst EventEmitter = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'events'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst QueryStream = __webpack_require__(/*! ./queryStream.js */ \"./node_modules/oracledb/lib/queryStream.js\");\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n//-----------------------------------------------------------------------------\n// execute()\n//   Executes a SQL statement and returns the results.\n//-----------------------------------------------------------------------------\nasync function execute(sql, a2, a3) {\n  let binds = [];\n  let executeOpts = {};\n\n  nodbUtil.checkArgCount(arguments, 1, 3);\n  nodbUtil.assert(typeof sql === 'string', 'NJS-005', 1);\n\n  switch (arguments.length) {\n    case 2:\n      nodbUtil.assert(nodbUtil.isObjectOrArray(a2), 'NJS-005', 2);\n      binds = a2;\n      break;\n    case 3:\n      nodbUtil.assert(nodbUtil.isObjectOrArray(a2), 'NJS-005', 2);\n      nodbUtil.assert(nodbUtil.isObject(a3), 'NJS-005', 3);\n      binds = a2;\n      executeOpts = a3;\n      break;\n  }\n\n  const result = await this._execute(sql, binds, executeOpts);\n\n  // process queries; if a result set is not desired, fetch all of the rows\n  // from the result set and then destroy the result set\n  if (result.resultSet && !executeOpts.resultSet) {\n    result.rows = await result.resultSet._getAllRows(executeOpts, result);\n    delete result.resultSet;\n  }\n\n  // process implicit results; ensure all implicit results have their fetch\n  // array size fixed, or, if a result set is not requested, that all rows are\n  // fetched\n  if (result.implicitResults) {\n    for (const key in result.implicitResults) {\n      const implicitResult = result.implicitResults[key];\n      if (!executeOpts.resultSet) {\n        result.implicitResults[key] =\n            await implicitResult._getAllRows(executeOpts);\n      }\n    }\n  }\n\n  return (result);\n}\n\n\n//-----------------------------------------------------------------------------\n// executeMany()\n//   Executes a SQL statement multiple times and returns the results.\n//-----------------------------------------------------------------------------\nasync function executeMany(sql, bindsOrNumIters, a3) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 2, 3);\n  nodbUtil.assert(typeof sql === 'string', 'NJS-005', 1);\n  if (typeof bindsOrNumIters === 'number') {\n    nodbUtil.assert(Number.isInteger(bindsOrNumIters), 'NJS-005', 2);\n    nodbUtil.assert(bindsOrNumIters > 0, 'NJS-005', 2);\n  } else {\n    nodbUtil.assert(Array.isArray(bindsOrNumIters), 'NJS-005', 2);\n    nodbUtil.assert(bindsOrNumIters.length > 0, 'NJS-005', 2);\n  }\n\n  if (arguments.length == 3) {\n    nodbUtil.assert(nodbUtil.isObject(a3), 'NJS-005', 3);\n    options = a3;\n  }\n\n  return (await this._executeMany(sql, bindsOrNumIters, options));\n}\n\n\n//-----------------------------------------------------------------------------\n// getDbObjectClass()\n//   Returns a database object class given its name. The cache is searched\n// first, but if not found, the database is queried and the result is cached\n// using the fully qualified name.\n//-----------------------------------------------------------------------------\nasync function getDbObjectClass(name) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(typeof name === 'string', 'NJS-005', 1);\n\n  let cls = this._dbObjectClasses[name];\n  if (cls) {\n    return cls;\n  }\n  return (await this._getDbObjectClass(name));\n}\n\n\n//-----------------------------------------------------------------------------\n// getStatementInfo()\n//   Returns information about the statement.\n//-----------------------------------------------------------------------------\nasync function getStatementInfo(sql) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  return (await this._getStatementInfo(sql));\n}\n\n\n//-----------------------------------------------------------------------------\n// commit()\n//   Commits the current transaction.\n//-----------------------------------------------------------------------------\nasync function commit() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  await this._commit();\n}\n\n\n//-----------------------------------------------------------------------------\n// createLob()\n//   Creates a temporary LOB and returns it to the caller.\n//-----------------------------------------------------------------------------\nasync function createLob(type) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(typeof type === 'number', 'NJS-005', 1);\n  return (await this._createLob(type));\n}\n\n\n//-----------------------------------------------------------------------------\n// rollback()\n//   Rolls back the current transaction.\n//-----------------------------------------------------------------------------\nasync function rollback() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  await this._rollback();\n}\n\n\n//-----------------------------------------------------------------------------\n// close()\n//   Closes the connection and makes it unusable for further work.\n//-----------------------------------------------------------------------------\nasync function close(a1) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 0, 1);\n  if (arguments.length == 1) {\n    nodbUtil.assert(nodbUtil.isObject(a1), 'NJS-005', 1);\n    options = a1;\n  }\n\n  // If already in the process of closing, throw an error instead of doing\n  // a roundtrip\n  if (this._closing) {\n    throw new Error (nodbUtil.getErrorMessage('NJS-003'));\n  }\n\n  this._closing = true;\n  try {\n    await this._close(options);\n  } finally {\n    this._closing = false;\n  }\n\n  for (const cls of Object.values(this._dbObjectClasses)) {\n    cls.prototype.constructor = Object;\n    cls.prototype = null;\n  }\n  this.emit('_afterConnClose');\n}\n\n\n//-----------------------------------------------------------------------------\n// break()\n//   Breaks the execution of the statement.\n//-----------------------------------------------------------------------------\nmodule.break = async function() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  await this._break();\n};\n\n\n//-----------------------------------------------------------------------------\n// changePassword()\n//   Changes the password of the specified user.\n//-----------------------------------------------------------------------------\nasync function changePassword(user, password, newPassword) {\n  nodbUtil.checkArgCount(arguments, 3, 3);\n  nodbUtil.assert(typeof user === 'string', 'NJS-005', 1);\n  nodbUtil.assert(typeof password === 'string', 'NJS-005', 2);\n  nodbUtil.assert(typeof newPassword === 'string', 'NJS-005', 3);\n  await this._changePassword(user, password, newPassword);\n}\n\n\n//-----------------------------------------------------------------------------\n// getQueue()\n//   Returns a queue with the specified name.\n//-----------------------------------------------------------------------------\nasync function getQueue(name, a2) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 1, 2);\n  nodbUtil.assert(typeof name === 'string', 'NJS-005', 1);\n  if (arguments.length == 2) {\n    nodbUtil.assert(nodbUtil.isObject(a2), 'NJS-005', 2);\n    options = a2;\n  }\n  return (await this._getQueue(name, options));\n}\n\n\n//-----------------------------------------------------------------------------\n// ping()\n//   Sends a \"ping\" to the database to see if it is \"alive\".\n//-----------------------------------------------------------------------------\nasync function ping() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  await this._ping();\n}\n\n\n//-----------------------------------------------------------------------------\n// shutdown()\n//   Shuts down the database instance.\n//-----------------------------------------------------------------------------\nasync function shutdown(a1) {\n  let mode = this._oracledb.SHUTDOWN_MODE_DEFAULT;\n\n  nodbUtil.checkArgCount(arguments, 0, 1);\n  if (a1 !== undefined) {\n    nodbUtil.assert(typeof mode === 'number', 'NJS-005', 1);\n    mode = a1;\n  }\n\n  await this._shutdown(mode);\n}\n\n\n//-----------------------------------------------------------------------------\n// startup()\n//   Starts up the database instance.\n//-----------------------------------------------------------------------------\nasync function startup(a1) {\n  let opts = {};\n\n  nodbUtil.checkArgCount(arguments, 0, 1);\n  if (arguments.length == 1) {\n    nodbUtil.assert(typeof opts === 'object', 'NJS-005', 1);\n    opts = a1;\n  }\n\n  await this._startup(opts);\n}\n\n\n//-----------------------------------------------------------------------------\n// subscribe()\n//   Creates a subscription which can be used to get notifications of database\n// changes or of AQ messages available to dequeue.\n//-----------------------------------------------------------------------------\nasync function subscribe(name, options) {\n  nodbUtil.checkArgCount(arguments, 2, 2);\n  nodbUtil.assert(typeof name === 'string', 'NJS-005', 1);\n  nodbUtil.assert(nodbUtil.isObject(options), 'NJS-005', 2);\n  await this._subscribe(name, options);\n}\n\n\n//-----------------------------------------------------------------------------\n// unsubscribe()\n//   Destroy a subscription which was earlier created using subscribe().\n//-----------------------------------------------------------------------------\nasync function unsubscribe(name) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(typeof name === 'string', 'NJS-005', 1);\n  await this._unsubscribe(name);\n}\n\n// build a database object class\nfunction buildDbObjectClass(schema, name, fqn) {\n  const DbObject = function(initialValue) {\n    if (this.isCollection) {\n      const proxy = new Proxy(this, BaseDbObject._collectionProxyHandler);\n      if (initialValue !== undefined) {\n        for (let i = 0; i < initialValue.length; i++) {\n          this.append(initialValue[i]);\n        }\n      }\n      return (proxy);\n    } else if (initialValue !== undefined) {\n      Object.assign(this, initialValue);\n    }\n  };\n  DbObject.prototype = Object.create(BaseDbObject.prototype);\n  DbObject.prototype.constructor = DbObject;\n  DbObject.prototype.schema = schema;\n  DbObject.prototype.name = name;\n  DbObject.prototype.fqn = fqn;\n  DbObject.toString = function() {\n    return ('DbObjectClass [' + fqn + ']');\n  };\n  return (DbObject);\n}\n\n//-----------------------------------------------------------------------------\n//  tpcBegin()\n//    Starts a two-phase-commit transaction\n//----------------------------------------------------------------------------\nasync function tpcBegin(xid, flag, timeout) {\n  nodbUtil.checkArgCount(arguments, 1, 3);\n  nodbUtil.assert(nodbUtil.isXid(xid), 'NJS-005', 1);\n\n  if (arguments.length < 3) {\n    timeout = 60;   // seconds\n  } else {\n    nodbUtil.assert(typeof timeout === 'number', 'NJS-005', 3);\n  }\n\n  if (arguments.length < 2) {\n    flag = this._oracledb.TPC_BEGIN_NEW;\n  } else {\n    nodbUtil.assert(typeof flag === 'number', 'NJS-005', 2);\n  }\n  await this._tpcBegin(xid, flag, timeout);\n}\n\n\n//-----------------------------------------------------------------------------\n//  tpcCommit\n//    Commit the two-phase-commit transaction\n//-----------------------------------------------------------------------------\nasync function tpcCommit(xid, onePhase) {\n  nodbUtil.checkArgCount(arguments, 0, 2);\n\n  if (arguments.length < 2) {\n    onePhase = false;\n  } else {\n    nodbUtil.assert(typeof onePhase === 'boolean', 'NJS-005', 2);\n  }\n  if (arguments.length >= 1) {\n    nodbUtil.assert(nodbUtil.isXid(xid), 'NJS-005', 1);\n  }\n  await this._tpcCommit(xid, onePhase);\n}\n\n\n//-----------------------------------------------------------------------------\n//  tpcEnd\n//    Ends the two-phase-commit transaction\n//-----------------------------------------------------------------------------\nasync function tpcEnd(xid, flag) {\n  nodbUtil.checkArgCount(arguments, 0, 2);\n\n  if (arguments.length < 2) {\n    flag = this._oracledb.TPC_END_NORMAL;\n  } else {\n    nodbUtil.assert(typeof flag === 'number', 'NJS-005', 2);\n  }\n\n  if (arguments.length >= 1) {\n    nodbUtil.assert(nodbUtil.isXid(xid), 'NJS-005', 1);\n  }\n\n  await this._tpcEnd(xid, flag);\n}\n\n\n//-----------------------------------------------------------------------------\n//  tpcForget\n//    causes the server to forget a heuristically completed global transaction.\n//-----------------------------------------------------------------------------\nasync function tpcForget(xid) {\n\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isXid(xid), 'NJS-005', 1);\n\n  await this._tpcForget(xid);\n}\n\n\n//-----------------------------------------------------------------------------\n//  tpcPrepare\n//    prepares a global transaction for commit.\n//-----------------------------------------------------------------------------\nasync function tpcPrepare(xid) {\n  nodbUtil.checkArgCount(arguments, 0, 1);\n\n  if (arguments.length >= 1) {\n    nodbUtil.assert(nodbUtil.isXid(xid), 'NJS-005', 1);\n  }\n\n  return await this._tpcPrepare(xid);\n}\n\n\n//-----------------------------------------------------------------------------\n//  tpcRecover\n//    Returns a list of pending transactions\n//-----------------------------------------------------------------------------\nasync function tpcRecover(asString) {\n  nodbUtil.checkArgCount(arguments, 0, 1);\n\n  if (arguments.length == 1) {\n    nodbUtil.assert(typeof asString === 'boolean', 'NJS-005', 1);\n  } else {\n    asString = true;\n  }\n\n  const sqlStr = `\n    SELECT\n        formatid as \"formatId\",\n        UTL_RAW.CAST_TO_VARCHAR2(globalid) as \"globalTransactionId\",\n        UTL_RAW.CAST_TO_VARCHAR2(branchid) as \"branchQualifier\"\n    FROM DBA_PENDING_TRANSACTIONS`;\n  const sqlBuf = `\n    SELECT\n        formatid as \"formatId\",\n        globalid as \"globalTransactionId\",\n        branchid as \"branchQualifier\"\n    FROM DBA_PENDING_TRANSACTIONS`;\n  const options = {\n    outFormat: this._oracledb.OUT_FORMAT_OBJECT,\n  };\n\n  const result = await this._execute(asString ? sqlStr : sqlBuf, {}, options);\n  return result.resultSet._getAllRows(options, result.metaData, false);\n}\n\n\n//-----------------------------------------------------------------------------\n//  tpcRollback()\n//    Rollbacks the current changes in two-phase-commit\n//-----------------------------------------------------------------------------\nasync function tpcRollback(xid) {\n  nodbUtil.checkArgCount(arguments, 0, 1);\n  if (arguments.length == 1) {\n    nodbUtil.assert(nodbUtil.isXid(xid), 'NJS-005', 1);\n  }\n\n  await this._tpcRollback(xid);\n}\n\n\n// define class\nclass Connection extends EventEmitter {\n\n  constructor() {\n    super();\n    this._dbObjectClasses = {};\n    this._requestQueue = [];\n    this._inProgress = false;\n    this._closing = false;\n  }\n\n  // extend class with promisified functions\n  _extend(oracledb) {\n    this._oracledb = oracledb;\n    this.break = nodbUtil.callbackify(module.break);  // should not be serialized\n    this.changePassword = nodbUtil.callbackify(nodbUtil.serialize(changePassword));\n    this.close = nodbUtil.callbackify(nodbUtil.serialize(close));\n    this.commit = nodbUtil.callbackify(nodbUtil.serialize(commit));\n    this.createLob = nodbUtil.callbackify(nodbUtil.serialize(createLob));\n    this.execute = nodbUtil.callbackify(nodbUtil.serialize(execute));\n    this.executeMany = nodbUtil.callbackify(nodbUtil.serialize(executeMany));\n    this.getDbObjectClass = nodbUtil.callbackify(nodbUtil.serialize(getDbObjectClass));\n    this.getQueue = nodbUtil.callbackify(nodbUtil.serialize(getQueue));\n    this.getStatementInfo = nodbUtil.callbackify(nodbUtil.serialize(getStatementInfo));\n    this.ping = nodbUtil.callbackify(nodbUtil.serialize(ping));\n    this.release = nodbUtil.callbackify(nodbUtil.serialize(close));\n    this.rollback = nodbUtil.callbackify(nodbUtil.serialize(rollback));\n    this.shutdown = nodbUtil.callbackify(nodbUtil.serialize(shutdown));\n    this.startup = nodbUtil.callbackify(nodbUtil.serialize(startup));\n    this.subscribe = nodbUtil.callbackify(nodbUtil.serialize(subscribe));\n    this.tpcBegin = nodbUtil.callbackify(nodbUtil.serialize(tpcBegin));\n    this.tpcCommit = nodbUtil.callbackify(nodbUtil.serialize(tpcCommit));\n    this.tpcEnd = nodbUtil.callbackify(nodbUtil.serialize(tpcEnd));\n    this.tpcForget = nodbUtil.callbackify(nodbUtil.serialize(tpcForget));\n    this.tpcPrepare = nodbUtil.callbackify(nodbUtil.serialize(tpcPrepare));\n    this.tpcRecover = nodbUtil.callbackify(nodbUtil.serialize(tpcRecover));\n    this.tpcRollback = nodbUtil.callbackify(nodbUtil.serialize(tpcRollback));\n    this.unsubscribe = nodbUtil.callbackify(nodbUtil.serialize(unsubscribe));\n  }\n\n  async _acquireLock() {\n    if (this._inProgress) {\n      if (this._oracledb.errorOnConcurrentExecute) {\n        throw new Error(nodbUtil.getErrorMessage('NJS-081'));\n      }\n      await new Promise((resolve, reject) => {\n        const payload = {resolve: resolve, reject: reject};\n        this._requestQueue.push(payload);\n      });\n    }\n    this._inProgress = true;\n  }\n\n  _getConnection() {\n    return this;\n  }\n\n  _getDbObjectClassJS(schema, name) {\n    const fqn = `${schema}.${name}`;\n    let cls = this._dbObjectClasses[fqn];\n    if (!cls) {\n      cls = buildDbObjectClass(schema, name, fqn);\n      cls._connection = this;\n      this._dbObjectClasses[fqn] = cls;\n    }\n    return (cls);\n  }\n\n  _isDate(val) {\n    return (util.isDate(val));\n  }\n\n  _releaseLock() {\n    if (this._requestQueue.length > 0) {\n      const payload = this._requestQueue.shift();\n      payload.resolve();\n    } else {\n      this._inProgress = false;\n    }\n  }\n\n  // To obtain a SodaDatabase object (high-level SODA object associated with\n  // current connection)\n  getSodaDatabase() {\n    nodbUtil.checkArgCount(arguments, 0, 0);\n    return (this._getSodaDatabase());\n  }\n\n  //--------------------------------------------------------------------------\n  //  isHealthy()\n  //    To get the health status of the connection.\n  //  NOTE: if this function returns false, the application must close the\n  //        connection obect.\n  //        This is a synchronous call.\n  //---------------------------------------------------------------------------\n  isHealthy() {\n    return (!this._closing && this._isHealthy());\n  }\n\n\n  // The queryStream function is similar to execute except that it immediately\n  // returns a QueryStream.\n  queryStream(sql, binding, options) {\n\n    nodbUtil.checkArgCount(arguments, 1, 3);\n    nodbUtil.assert(typeof sql === 'string', 'NJS-005', 1);\n\n    if (binding) {\n      nodbUtil.assert(nodbUtil.isObjectOrArray(binding), 'NJS-005', 2);\n    }\n\n    if (options) {\n      nodbUtil.assert(nodbUtil.isObject(options), 'NJS-005', 3);\n    }\n\n    binding = binding || [];\n    options = options || {};\n\n    options.resultSet = true;\n\n    const stream = new QueryStream();\n\n    // calling execute() via nextTick to ensure that handlers are registered\n    // prior to the events being emitted\n    process.nextTick(() => {\n      try {\n        const p = this._execute(sql, binding, options);\n        p.then(function(result) {\n          if (!result.resultSet) {\n            stream.destroy(new Error(nodbUtil.getErrorMessage('NJS-019')));\n          } else {\n            stream._open(result.resultSet);\n          }\n        }, function(err) {\n          stream.destroy(err);\n        });\n      } catch (err) {\n        stream.destroy(err);\n        return;\n      }\n    });\n\n    return (stream);\n  }\n\n}\n\n\n// module.exports.extend = extend;\nmodule.exports = Connection;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/connection.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/dbObject.js":
/*!***********************************************!*\
  !*** ./node_modules/oracledb/lib/dbObject.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2019, 2022, Oracle and/or its affiliates.\n//\n//----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n// define base database object class; instances of this class are never\n// instantiated; instead, classes subclassed from this one will be\n// instantiated; a cache of these classes are maintained on each connection\nclass BaseDbObject {\n\n  // extend class with promisified functions\n  _extend(oracledb) {\n    this._oracledb = oracledb;\n  }\n\n  // initialize object with value\n  _initialize(initialValue) {\n    if (this.isCollection) {\n      for (let i = 0; i < initialValue.length; i++) {\n        this.append(initialValue[i]);\n      }\n    } else {\n      Object.assign(this, initialValue);\n    }\n  }\n\n  // return as a plain object\n  _toPojo() {\n    if (this.isCollection) {\n      const result = this.getValues();\n      if (this.elementType == this._oracledb.DB_TYPE_OBJECT) {\n        for (let i = 0; i < result.length; i++) {\n          result[i] = result[i]._toPojo();\n        }\n      }\n      return (result);\n    }\n    const result = {};\n    for (let name in this.attributes) {\n      let value = this[name];\n      if (value instanceof BaseDbObject) {\n        value = value._toPojo();\n      }\n      result[name] = value;\n    }\n    return (result);\n  }\n\n  // custom inspection routine\n  [util.inspect.custom](depth, options) {\n    return ('[' + this.fqn + '] ' + util.inspect(this._toPojo(), options));\n  }\n\n  [Symbol.iterator]() {\n    if (this.isCollection) {\n      const values = this.getValues();\n      return (values[Symbol.iterator]());\n    }\n    throw TypeError(\"obj is not iterable\");\n  }\n\n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'number':\n        return (NaN);\n      default:\n        return ('[' + this.fqn + '] ' + util.inspect(this._toPojo(), {}));\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return (this.fqn);\n  }\n\n  toJSON() {\n    return (this._toPojo());\n  }\n\n}\n\n\n// define proxy handler used for collections\nBaseDbObject._collectionProxyHandler = {\n\n  deleteProperty(target, prop) {\n    if (typeof prop === 'string') {\n      const index = +prop;\n      if (!isNaN(index)) {\n        return (target.deleteElement(index));\n      }\n    }\n    return (delete target[prop]);\n  },\n\n  get(target, prop) {\n    if (typeof prop === 'string') {\n\n      // when binding collections, we must be consistent in getting the target\n      // of the proxy, since napi_wrap() called on the proxy will not be\n      // available when calling napi_unwrap() on the target; this property\n      // forces the target to get returned\n      if (prop === '_target') {\n        return (target);\n      }\n      const index = +prop;\n      if (!isNaN(index)) {\n        return (target.getElement(index));\n      }\n    }\n    const value = target[prop];\n    if (typeof value === 'function') {\n      return (value.bind(target));\n    }\n    return (value);\n  },\n\n  set(target, prop, value) {\n    if (typeof prop === 'string') {\n      const index = +prop;\n      if (!isNaN(index)) {\n        target.setElement(index, value);\n        return (true);\n      }\n    }\n    target[prop] = value;\n    return (true);\n  }\n\n};\n\n\nmodule.exports = BaseDbObject;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/dbObject.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/lob.js":
/*!******************************************!*\
  !*** ./node_modules/oracledb/lib/lob.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2016, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst { Duplex } = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\n\n//-----------------------------------------------------------------------------\n// close()\n//   Close the LOB and make it unusable for further operations. If the LOB is\n// already closed, nothing is done in order to support multiple close() calls.\n//\n//   This method is deprecated and will be removed in a future version of the\n// node-oracledb driver. Use lob.destroy() instead. NOTE: this method will\n// emit a duplicate \"close\" event in order to be compatible with previous\n// versions of node-oracledb.\n//-----------------------------------------------------------------------------\nasync function close() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  if (this.valid) {\n    try {\n      await this._close();\n      this.emit('close');\n    } catch (err) {\n      this.destroy(err);\n    }\n  }\n}\n\n\n//-----------------------------------------------------------------------------\n// getData()\n//   Returns all of the data in the LOB as a single string or buffer.\n//-----------------------------------------------------------------------------\nasync function getData() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._getData();\n}\n\n\nclass Lob extends Duplex {\n\n  constructor() {\n    super({ decodeStrings: false });\n    this.offset = 1;\n    this._isActive = false;\n    this.once('finish', function() {\n      if (this._autoCloseLob) {\n        this.destroy();\n      }\n    });\n  }\n\n  _extend(oracledb) {\n    this._oracledb = oracledb;\n    this.close = nodbUtil.callbackify(nodbUtil.preventConcurrent(nodbUtil.serialize(close), 'NJS-023'));\n    this.getData = nodbUtil.callbackify(nodbUtil.preventConcurrent(nodbUtil.serialize(getData), 'NJS-023'));\n    this._serializedRead = nodbUtil.serialize(this.__read);\n    this._serializedWrite = nodbUtil.serialize(this.__write);\n  }\n\n  // called by stream.destroy() and ensures that the LOB is closed if it has\n  // not already been closed (never called directly)\n  async _destroy(err, cb) {\n    if (this.valid) {\n      try {\n        await this._close();\n      } catch (closeErr) {\n        cb(closeErr);\n        return;\n      }\n    }\n    cb(err);\n  }\n\n  // return the connection associated with the LOB (used for serializing\n  // accesses to the connection)\n  _getConnection() {\n    let connection = this._parentObj;\n    while (!(connection instanceof this._oracledb.Connection))\n      connection = connection._parentObj;\n    return connection;\n  }\n\n  // implementation of streaming read; if lob is set to auto-close, the lob is\n  // automatically closed within the C code when an error occurs or when there\n  // are no more bytes to transfer; all that needs to be done in the JS layer\n  // is to destroy the streaming LOB\n  async _read() {\n    try {\n      const data = await this._serializedRead(this.offset);\n      if (data) {\n        this.offset += data.length;\n        this.push(data);\n      } else {\n        this.push(null);\n        if (this._autoCloseLob) {\n          this.destroy();\n        }\n      }\n    } catch (err) {\n      this.destroy(err);\n    }\n  }\n\n  // implementation of streaming write; if lob is set to auto-close, the lob is\n  // automatically closed in the \"finish\" event; all that needs to be done here\n  // is to destroy the streaming LOB\n  async _write(data, encoding, cb) {\n\n    // convert data if needed\n    if (this.type == this._oracledb.DB_TYPE_BLOB && !Buffer.isBuffer(data)) {\n      data = Buffer.from(data);\n    } else if (this.type == this._oracledb.DB_TYPE_CLOB &&\n        Buffer.isBuffer(data)) {\n      data = data.toString();\n    }\n\n    try {\n      await this._serializedWrite(this.offset, data);\n    } catch (err) {\n      cb(err);\n      this.destroy(err);\n      return;\n    }\n    this.offset += data.length;\n    cb(null);\n\n  }\n\n}\n\nmodule.exports = Lob;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/lob.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/oracledb.js":
/*!***********************************************!*\
  !*** ./node_modules/oracledb/lib/oracledb.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("var __dirname = \"/\";\n// Copyright (c) 2015, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n// This version of node-oracledb works with Node.js 8.16, 10.16 or\n// later.  The test stops hard-to-interpret runtime errors and crashes\n// with older Node.js versions.  Also Node.js 8.16 and 10.16 (and\n// 12.0) contain an important Node-API performance regression fix.  If\n// you're using the obsolete Node.js 9 or 11 versions, you're on your\n// own regarding performance and functionality\nlet vs = process.version.substring(1).split(\".\").map(Number);\nif (vs[0] < 8 || (vs[0] === 8 && vs[1] < 16)) {\n  throw new Error(nodbUtil.getErrorMessage('NJS-069', nodbUtil.PACKAGE_JSON_VERSION, \"8.16\"));\n} else if ((vs[0] === 10 && vs[1] < 16)) {\n  throw new Error(nodbUtil.getErrorMessage('NJS-069', nodbUtil.PACKAGE_JSON_VERSION, \"10.16\"));\n}\n\nconst AqDeqOptions = __webpack_require__(/*! ./aqDeqOptions.js */ \"./node_modules/oracledb/lib/aqDeqOptions.js\");\nconst AqEnqOptions = __webpack_require__(/*! ./aqEnqOptions.js */ \"./node_modules/oracledb/lib/aqEnqOptions.js\");\nconst AqMessage = __webpack_require__(/*! ./aqMessage.js */ \"./node_modules/oracledb/lib/aqMessage.js\");\nconst AqQueue = __webpack_require__(/*! ./aqQueue.js */ \"./node_modules/oracledb/lib/aqQueue.js\");\nconst BaseDbObject = __webpack_require__(/*! ./dbObject.js */ \"./node_modules/oracledb/lib/dbObject.js\");\nconst Connection = __webpack_require__(/*! ./connection.js */ \"./node_modules/oracledb/lib/connection.js\");\nconst Lob = __webpack_require__(/*! ./lob.js */ \"./node_modules/oracledb/lib/lob.js\");\nconst Pool = __webpack_require__(/*! ./pool.js */ \"./node_modules/oracledb/lib/pool.js\");\nconst PoolStatistics = __webpack_require__(/*! ./poolStatistics.js */ \"./node_modules/oracledb/lib/poolStatistics.js\");\nconst ResultSet = __webpack_require__(/*! ./resultset.js */ \"./node_modules/oracledb/lib/resultset.js\");\nconst SodaDatabase = __webpack_require__(/*! ./sodaDatabase.js */ \"./node_modules/oracledb/lib/sodaDatabase.js\");\nconst SodaCollection = __webpack_require__(/*! ./sodaCollection.js */ \"./node_modules/oracledb/lib/sodaCollection.js\");\nconst SodaDocCursor = __webpack_require__(/*! ./sodaDocCursor.js */ \"./node_modules/oracledb/lib/sodaDocCursor.js\");\nconst SodaDocument = __webpack_require__(/*! ./sodaDocument.js */ \"./node_modules/oracledb/lib/sodaDocument.js\");\nconst SodaOperation = __webpack_require__(/*! ./sodaOperation.js */ \"./node_modules/oracledb/lib/sodaOperation.js\");\n\nlet poolCache = {};\nlet tempUsedPoolAliases = {};\nconst defaultPoolAlias = 'default';\n\n// Load the Oracledb binary\n\n/*global __non_webpack_require__*/  // quieten eslint\nconst requireBinary = (typeof require === 'function') ? require : __webpack_require__(\"./node_modules/oracledb/lib sync recursive\"); // See Issue 1156\n\nconst binaryLocations = [\n  '../' + nodbUtil.RELEASE_DIR + '/' + nodbUtil.BINARY_FILE,  // pre-built binary\n  '../' + nodbUtil.RELEASE_DIR + '/' + 'oracledb.node',       // binary built from source\n  '../build/Debug/oracledb.node',                             // debug binary\n  // For Webpack.  A Webpack copy plugin is still needed to copy 'node_modules/oracledb/build/' to the output directory\n  // See https://github.com/oracle/node-oracledb/issues/1156\n  './node_modules/oracledb/' + nodbUtil.RELEASE_DIR + '/' + nodbUtil.BINARY_FILE,\n  './node_modules/oracledb/' + nodbUtil.RELEASE_DIR + '/' + 'oracledb.node'\n];\n\nlet oracledbCLib;\nfor (let i = 0; i < binaryLocations.length; i++) {\n  try {\n    oracledbCLib = requireBinary(binaryLocations[i]);\n    break;\n  } catch (err) {\n    if (err.code !== 'MODULE_NOT_FOUND' || i == binaryLocations.length - 1) {\n      let nodeInfo;\n      if (err.code === 'MODULE_NOT_FOUND') {\n        // A binary was not found in any of the search directories.\n        // Note this message may not be accurate for Webpack users since Webpack changes __dirname\n        nodeInfo = `\\n  Looked for ${binaryLocations.map(x => Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(__dirname, x)).join(', ')}\\n  ${nodbUtil.getInstallURL()}\\n`;\n      } else {\n        nodeInfo = `\\n  Node.js require('oracledb') error was:\\n  ${err.message}\\n  ${nodbUtil.getInstallHelp()}\\n`;\n      }\n      throw new Error(nodbUtil.getErrorMessage('NJS-045', nodeInfo));\n    }\n  }\n}\n\n\nclass OracleDb {\n\n  constructor() {\n    this.queueTimeout = 60000;\n    this.queueMax     = 500;\n    this.errorOnConcurrentExecute = false;\n  }\n\n  // extend class with promisified functions\n  _extend(_oracledb) {\n    this.getConnection = nodbUtil.callbackify(getConnection).bind(_oracledb);\n    this.createPool = nodbUtil.callbackify(createPool).bind(_oracledb);\n    this.shutdown = nodbUtil.callbackify(shutdown).bind(_oracledb);\n    this.startup = nodbUtil.callbackify(startup).bind(_oracledb);\n    this.initOracleClient = this.initOracleClient.bind(_oracledb);\n    this._accessTokenHandler = this._accessTokenHandler.bind(_oracledb);\n  }\n\n  // temporary method for determining if an object is a date until\n  // napi_is_date() can be used (when Node-API v5 can be used)\n  _isDate(val) {\n    return util.isDate(val);\n  }\n\n  // handler for access token callbacks\n  async _accessTokenHandler(userFn, externalObj, refresh) {\n    let accessToken;\n    try {\n      let result = userFn(refresh);\n      if (result instanceof Promise) {\n        result = await result;\n      }\n\n      _checkToken(result);\n      accessToken = result;\n    } finally {\n      this._returnAccessToken(externalObj, accessToken);\n    }\n  }\n\n  // retrieves a pool from the pool cache (synchronous method)\n  getPool(poolAlias) {\n    let pool;\n\n    nodbUtil.checkArgCount(arguments, 0, 1);\n\n    if (poolAlias) {\n      nodbUtil.assert(typeof poolAlias === 'string' || typeof poolAlias === 'number', 'NJS-005', 1);\n    }\n\n    poolAlias = poolAlias || defaultPoolAlias;\n\n    pool = poolCache[poolAlias];\n\n    if (!pool) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-047', poolAlias));\n    }\n\n    return pool;\n  }\n\n  initOracleClient(arg1) {\n    let options = {};\n    nodbUtil.checkArgCount(arguments, 0, 1);\n    if (arg1 !== undefined) {\n      nodbUtil.assert(nodbUtil.isObject(arg1), 'NJS-005', 1);\n      options = arg1;\n    }\n    this._initOracleClient(options);\n  }\n\n}\n\n// Oracledb functions and classes\n\n//-----------------------------------------------------------------------------\n// createPool()\n//   Create a pool with the specified options and return it to the caller.\n//-----------------------------------------------------------------------------\nasync function createPool(poolAttrs) {\n  let poolAlias;\n\n  // check arguments\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isObject(poolAttrs), 'NJS-005', 1);\n  if (poolAttrs.poolAlias !== undefined) {\n    if (typeof poolAttrs.poolAlias !== 'string' ||\n        poolAttrs.poolAlias.length === 0) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-004',\n        'poolAttrs.poolAlias'));\n    }\n    poolAlias = poolAttrs.poolAlias;\n  } else if (poolAttrs.poolAlias === undefined\n      && !poolCache[defaultPoolAlias]\n      && !tempUsedPoolAliases[defaultPoolAlias]) {\n    poolAlias = defaultPoolAlias;\n  }\n  if (poolCache[poolAlias] || tempUsedPoolAliases[poolAlias]) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-046', poolAlias));\n  }\n\n  if (poolAttrs.accessToken !== undefined) {\n    // cannot set username or password for token based authentication\n    if (poolAttrs.user !== undefined ||\n        poolAttrs.password !== undefined) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-084'));\n    }\n\n    // homogeneous and externalAuth must be set to true for token based\n    // authentication\n    if (poolAttrs.homogeneous === false ||\n        poolAttrs.externalAuth === false) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-085'));\n    }\n  }\n\n  // create an adjusted set of pool attributes to pass to the C layer; the\n  // session callback must be removed if it is a JavaScript function and the\n  // queue timeout is used to specify the maximum amount of time that the C\n  // layer will wait for a connection to be returned; ordinarily since the\n  // JavaScript layer never calls the C layer to get a connection unless one is\n  // known to be available, this should not be needed, but in some cases (such\n  // as when the maximum for a particular shard is specified) this may not be\n  // known, so this prevents an unnecessarily long wait from taking place\n  const adjustedPoolAttrs = Object.defineProperties({},\n    Object.getOwnPropertyDescriptors(poolAttrs));\n  if (typeof poolAttrs.sessionCallback === 'function') {\n    delete adjustedPoolAttrs.sessionCallback;\n  }\n  if (adjustedPoolAttrs.queueTimeout === undefined) {\n    adjustedPoolAttrs.queueTimeout = this.queueTimeout;\n  }\n\n  // token based authentication\n  if (poolAttrs.accessToken !== undefined) {\n    // accessTokenCallback is depricated from node-oracledb 5.5\n    if (poolAttrs.accessTokenCallback !== undefined &&\n        typeof poolAttrs.accessToken === 'function') {\n      throw new Error(nodbUtil.getErrorMessage('NJS-088'));\n    }\n\n    let accessToken;\n    if (typeof poolAttrs.accessToken === 'function') {\n      adjustedPoolAttrs.accessTokenCallback = poolAttrs.accessToken;\n      accessToken = await poolAttrs.accessToken(false);\n\n      if (_isTokenExpired(accessToken)) {\n        accessToken = await poolAttrs.accessToken(true);\n      }\n    } else {\n      accessToken = poolAttrs.accessToken;\n    }\n    _checkToken(accessToken, adjustedPoolAttrs);\n  }\n\n  // Need to prevent another call in the same stack from succeeding, otherwise\n  // two pools could be created with the same poolAlias and the second one that\n  // comes back would overwrite the first in the cache.\n  if (poolAlias) {\n    tempUsedPoolAliases[poolAlias] = true;\n  }\n\n  try {\n    const pool = await this._createPool(adjustedPoolAttrs);\n\n    if (poolAlias) {\n      poolCache[poolAlias] = pool;\n\n      // It's now safe to remove this alias from the tempUsedPoolAliases.\n      delete tempUsedPoolAliases[poolAlias];\n    }\n\n    pool._setup(poolAttrs, poolAlias, this);\n    pool.on('_afterPoolClose', () => {\n      if (pool.poolAlias) {\n        delete poolCache[pool.poolAlias];\n      }\n    });\n\n    return pool;\n\n  } catch (err) {\n\n    // We need to free this up since the creation of the pool failed.\n    if (poolAlias) {\n      delete tempUsedPoolAliases[poolAlias];\n    }\n\n    // add installation help instructions to error message, if applicable\n    if (err.message.match(/DPI-1047/)) {\n      err.message += \"\\n\" + nodbUtil.getInstallHelp();\n    }\n\n    throw err;\n  }\n}\n\n\n//-----------------------------------------------------------------------------\n// getConnection()\n//   Gets either a standalone connection, or a connection from a pool cache\n//-----------------------------------------------------------------------------\nasync function getConnection(a1) {\n  let pool;\n  let poolAlias;\n  let connAttrs = {};\n\n  // verify the number and types of arguments\n  nodbUtil.checkArgCount(arguments, 0, 1);\n  if (arguments.length == 0) {\n    poolAlias = defaultPoolAlias;\n  } else {\n    nodbUtil.assert(typeof a1 === 'string' || nodbUtil.isObject(a1),\n      'NJS-005', 1);\n    if (typeof a1 === 'string') {\n      poolAlias = a1;\n    } else {\n      connAttrs = a1;\n      if (connAttrs.poolAlias) {\n        poolAlias = connAttrs.poolAlias;\n      }\n    }\n  }\n\n  // if a pool alias is available, acquire a connection from the specified pool\n  if (poolAlias) {\n    pool = poolCache[poolAlias];\n    if (!pool) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-047', poolAlias));\n    }\n    return await pool.getConnection(connAttrs);\n\n  // otherwise, create a new standalone connection\n  } else {\n    if (connAttrs.accessToken !== undefined) {\n      // cannot set username or password for token based authentication\n      if (connAttrs.user !== undefined ||\n          connAttrs.password !== undefined) {\n        throw new Error(nodbUtil.getErrorMessage('NJS-084'));\n      }\n\n      // externalAuth must be set to true for token based authentication\n      if (connAttrs.externalAuth === false) {\n        throw new Error(nodbUtil.getErrorMessage('NJS-086'));\n      }\n\n      let accessToken;\n      if (typeof connAttrs.accessToken === 'function') {\n        accessToken = await connAttrs.accessToken(false);\n\n        if (_isTokenExpired(accessToken)) {\n          accessToken = await connAttrs.accessToken(true);\n        }\n      } else {\n        accessToken = connAttrs.accessToken;\n      }\n      _checkToken(accessToken, connAttrs);\n    }\n\n    try {\n      return await this._getConnection(connAttrs);\n    } catch (err) {\n      if (err.message.match(/DPI-1047/)) {\n        err.message += \"\\n\" + nodbUtil.getInstallHelp();\n      }\n      throw err;\n    }\n  }\n}\n\n\n//-----------------------------------------------------------------------------\n// shutdown()\n//   Shuts down the database.\n//-----------------------------------------------------------------------------\nasync function shutdown(a1, a2) {\n  let connAttr = {};\n  let shutdownMode = this.SHUTDOWN_MODE_DEFAULT;\n\n  // verify the number and types of arguments\n  nodbUtil.checkArgCount(arguments, 0, 2);\n  if (arguments.length == 2) {\n    nodbUtil.assert(typeof a1 === 'object', 'NJS-005', 1);\n    nodbUtil.assert(typeof a2 === 'number', 'NJS-005', 2);\n    connAttr = a1;\n    shutdownMode = a2;\n  } else if (arguments.length == 1) {\n    nodbUtil.assert(typeof a1 === 'object', 'NJS-005', 1);\n    connAttr = a1;\n  }\n\n  // only look for the keys that are used for shutting down the database\n  // use SYSOPER privilege\n  const dbConfig = {\n    user: connAttr.user,\n    password: connAttr.password,\n    connectString: connAttr.connectString,\n    connectionString: connAttr.connectionString,\n    externalAuth: connAttr.externalAuth,\n    privilege: this.SYSOPER\n  };\n\n  const conn = await this.getConnection(dbConfig);\n  await conn.shutdown(shutdownMode);\n  if (shutdownMode != this.SHUTDOWN_MODE_ABORT) {\n    await conn.execute(\"ALTER DATABASE CLOSE\");\n    await conn.execute(\"ALTER DATABASE DISMOUNT\");\n    await conn.shutdown(this.SHUTDOWN_MODE_FINAL);\n  }\n  await conn.close();\n}\n\n\n//-----------------------------------------------------------------------------\n// startup()\n//   Starts up the database.\n//-----------------------------------------------------------------------------\nasync function startup(a1, a2) {\n  let connAttr = {};\n  let startupAttr = {};\n\n  // verify the number and types of arguments\n  nodbUtil.checkArgCount(arguments, 0, 2);\n  if (arguments.length == 2) {\n    nodbUtil.assert (typeof a1 === 'object', 'NJS-005', 1);\n    nodbUtil.assert (typeof a2 === 'object', 'NJS-005', 2);\n    connAttr = a1;\n    startupAttr = a2;\n  } else if (arguments.length == 1) {\n    nodbUtil.assert(typeof a1 === 'object', 'NJS-005', 1);\n    connAttr = a1;\n  }\n\n  // only look for the keys that are used for starting up the database\n  // use SYSOPER and SYSPRELIM privileges\n  const dbConfig = {\n    user: connAttr.user,\n    password: connAttr.password,\n    connectString: connAttr.connectString,\n    connectionString: connAttr.connectionString,\n    externalAuth: connAttr.externalAuth,\n    privilege: this.SYSOPER | this.SYSPRELIM\n  };\n\n  let conn = await this.getConnection(dbConfig);\n  await conn.startup(startupAttr);\n  await conn.close();\n\n  dbConfig.privilege = this.SYSOPER;\n  conn = await this.getConnection(dbConfig);\n  await conn.execute(\"ALTER DATABASE MOUNT\");\n  await conn.execute(\"ALTER DATABASE OPEN\");\n  await conn.close();\n}\n\n\n//-----------------------------------------------------------------------------\n// _isTokenExpiredUtil()\n//   Function to check validity and expiry of token\n//-----------------------------------------------------------------------------\nfunction _isTokenExpiredUtil(accessToken) {\n  nodbUtil.assert(typeof accessToken === 'string', 'NJS-084', 1);\n\n  if (accessToken.split('.')[1] === undefined) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-084'));\n  }\n\n  const base64Url = accessToken.split('.')[1];\n  const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n  const buff = Buffer.from(base64, 'base64');\n  const payloadInit = buff.toString('ascii');\n\n  let expiry = JSON.parse(payloadInit).exp;\n  nodbUtil.assert(expiry != undefined, 'NJS-084');\n  expiry = expiry * 1000;\n\n  return (new Date().getTime() > expiry);\n}\n\n\n//-----------------------------------------------------------------------------\n// _isTokenExpired()\n//   Function to check validity of token parameter\n//-----------------------------------------------------------------------------\nfunction _isTokenExpired(accessToken) {\n  switch (typeof accessToken) {\n    case 'string':\n      if (accessToken === '') {\n        throw new Error(nodbUtil.getErrorMessage('NJS-084'));\n      }\n\n      return _isTokenExpiredUtil(accessToken);\n    case 'object':\n      if (accessToken.token === undefined ||\n          accessToken.token === '' ||\n          accessToken.privateKey === undefined ||\n          accessToken.privateKey === '') {\n        throw new Error(nodbUtil.getErrorMessage('NJS-084'));\n      }\n\n      return _isTokenExpiredUtil(accessToken.token);\n    default:\n      throw new Error(nodbUtil.getErrorMessage('NJS-084'));\n  }\n}\n\n\n//-----------------------------------------------------------------------------\n// _checkToken()\n//   Function to check validity of token parameter\n//-----------------------------------------------------------------------------\nfunction _checkToken(accessToken, attrs) {\n  if (_isTokenExpired(accessToken)) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-087'));\n  }\n\n  if (attrs === undefined)\n    return;\n\n  if (typeof accessToken === 'string') {\n    attrs.token = accessToken;\n  } else {\n    attrs.token = accessToken.token;\n    attrs.privateKey = accessToken.privateKey;\n  }\n}\n\n\n// create instance which will be exported\nlet oracleDbInst = new OracleDb();\n\n// add classes to prototype\nlet proto = Object.getPrototypeOf(oracleDbInst);\nproto.OracleDb = OracleDb;\nproto.AqDeqOptions = AqDeqOptions;\nproto.AqEnqOptions = AqEnqOptions;\nproto.AqMessage = AqMessage;\nproto.AqQueue = AqQueue;\nproto.BaseDbObject = BaseDbObject;\nproto.Connection = Connection;\nproto.Lob = Lob;\nproto.Pool = Pool;\nproto.PoolStatistics = PoolStatistics;\nproto.ResultSet = ResultSet;\nproto.SodaDatabase = SodaDatabase;\nproto.SodaCollection = SodaCollection;\nproto.SodaDocCursor = SodaDocCursor;\nproto.SodaDocument = SodaDocument;\nproto.SodaOperation = SodaOperation;\n\n// call C to extend classes\noracledbCLib.init(oracleDbInst);\n\nmodule.exports = oracleDbInst;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/oracledb.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/pool.js":
/*!*******************************************!*\
  !*** ./node_modules/oracledb/lib/pool.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2016, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst EventEmitter = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'events'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\nconst PoolStatistics = __webpack_require__(/*! ./poolStatistics.js */ \"./node_modules/oracledb/lib/poolStatistics.js\");\n\n\n//-----------------------------------------------------------------------------\n// _checkRequestQueue()\n//   When a connection is returned to the pool, this method is called (via an\n// event handler) to determine when requests for connections should be\n// resumed and cancels any timeout that may have been associated with the\n// request. This method is also called from reconfigure() so that waiting\n// connection requests can be processed. Note the use of a local variable for\n// the number of connections out. This is because the connection requests will\n// not resume until after the loop is finished, and therefore the number of\n// connections the pool thinks is out will not be incremented.\n//-----------------------------------------------------------------------------\nfunction _checkRequestQueue() {\n  let connectionsOut = this._connectionsOut;\n  while (this._connRequestQueue.length > 0 && connectionsOut < this.poolMax) {\n    connectionsOut += 1;\n    const payload = this._connRequestQueue.shift();\n    if (this._enableStatistics) {\n      this._totalRequestsDequeued += 1;\n      this._updateWaitStatistics(payload);\n    }\n    if (payload.timeoutHandle) {\n      clearTimeout(payload.timeoutHandle);\n    }\n    // inform the waiter that processing can continue\n    payload.resolve();\n  }\n}\n\n\n//-----------------------------------------------------------------------------\n// getConnection()\n//   Gets a connection from the pool and returns it to the caller. If there are\n// fewer connections out than the poolMax setting, then the request will\n// return immediately; otherwise, the request will be queued for up to\n// queueTimeout milliseconds.\n//-----------------------------------------------------------------------------\nasync function getConnection(a1) {\n  let poolMax;\n  let options = {};\n\n  // check arguments\n  nodbUtil.checkArgCount(arguments, 0, 1);\n  if (arguments.length == 1) {\n    nodbUtil.assert(nodbUtil.isObject(a1), 'NJS-005', 1);\n    options = a1;\n  }\n\n  // if pool is draining/closed, throw an appropriate error\n  this._checkPoolOpen(true);\n\n  // manage stats, if applicable\n  if (this._enableStatistics) {\n    this._totalConnectionRequests += 1;\n  }\n\n  // getting the poolMax setting on the pool may fail if the pool is no longer\n  // valid\n  try {\n    poolMax = this.poolMax;\n  } catch (err) {\n    if (this._enableStatistics) {\n      this._totalFailedRequests += 1;\n    }\n    throw err;\n  }\n\n  if (this._connectionsOut >= poolMax ||\n      this.status === this._oracledb.POOL_STATUS_RECONFIGURING) {\n\n    // when the queue is huge, throw error early without waiting for queue timeout\n    if (this._connRequestQueue.length >= this._queueMax &&\n        this._queueMax >= 0) {\n      if (this._enableStatistics) {\n        this._totalRequestsRejected += 1;\n      }\n      throw new Error(nodbUtil.getErrorMessage('NJS-076', this._queueMax));\n    }\n\n    // if too many connections are out, wait until room is made available or the\n    // queue timeout expires\n    await new Promise((resolve, reject) => {\n\n      // set up a payload which will be added to the queue for processing\n      const payload = { resolve: resolve, reject: reject };\n\n      // if using a queue timeout, establish the timeout so that when it\n      // expires the payload will be removed from the queue and an exception\n      // thrown\n      if (this._queueTimeout !== 0) {\n        payload.timeoutHandle = setTimeout(() => {\n          const ix = this._connRequestQueue.indexOf(payload);\n          if (ix >= 0) {\n            this._connRequestQueue.splice(ix, 1);\n          }\n          if (this._enableStatistics) {\n            this._totalRequestTimeouts += 1;\n            this._updateWaitStatistics(payload);\n          }\n          reject(new Error(nodbUtil.getErrorMessage('NJS-040',\n            this._queueTimeout)));\n        }, this._queueTimeout);\n      }\n\n      // add payload to the queue\n      this._connRequestQueue.push(payload);\n      if (this._enableStatistics) {\n        payload.enqueuedTime = Date.now();\n        this._totalRequestsEnqueued += 1;\n        this._maximumQueueLength = Math.max(this._maximumQueueLength,\n          this._connRequestQueue.length);\n      }\n\n    });\n\n    // check if pool is draining/closed after delay has\n    // completed and throw an appropriate error\n    this._checkPoolOpen(true);\n\n  }\n\n  // room is available in the queue, so proceed to acquire a connection from\n  // the pool; adjust the connections out immediately in order to ensure that\n  // another attempt doesn't proceed while this one is underway\n  this._connectionsOut += 1;\n  try {\n\n    // acquire connection from the pool\n    const conn = await this._getConnection(options);\n\n    // invoke tag fixup callback method if one has been specified and the\n    // actual tag on the connection doesn't match the one requested, or the\n    // connection is freshly created; if the callback fails, close the\n    // connection and remove it from the pool\n    const requestedTag = options.tag || \"\";\n    if (typeof this.sessionCallback === 'function' &&\n        (conn._newSession || conn.tag != requestedTag)) {\n      try {\n        await new Promise((resolve, reject) => {\n          this.sessionCallback(conn, requestedTag, function(err) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      } catch (err) {\n        await conn.close({ drop: true });\n        throw err;\n      }\n    }\n\n    // when connection is closed, check to see if another request should be\n    // processed and update any stats, as needed\n    conn.on('_afterConnClose', () => {\n      this._connectionsOut -= 1;\n      this.emit('_checkRequestQueue');\n      if (this._connectionsOut == 0) {\n        this.emit('_allCheckedIn');\n      }\n    });\n\n    return (conn);\n\n  } catch (err) {\n    this._connectionsOut -= 1;\n    if (this._enableStatistics) {\n      this._totalFailedRequests += 1;\n    }\n    this.emit('_checkRequestQueue');\n    throw err;\n  }\n\n}\n\n\n//-----------------------------------------------------------------------------\n// reconfigure()\n//   Reconfigure the pool, change the value for given pool-properties.\n//-----------------------------------------------------------------------------\nasync function reconfigure(options) {\n\n  // check arguments\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isObject(options));\n\n  // reconfiguration can happen only when status is OPEN\n  this._checkPoolOpen(false);\n\n  if ((options.queueMax !== undefined) &&\n      (typeof options.queueMax !== \"number\"))\n    throw new Error(nodbUtil.getErrorMessage('NJS-004', \"queueMax\"));\n\n  if ((options.queueTimeout !== undefined) &&\n      (typeof options.queueTimeout !== \"number\"))\n    throw new Error(nodbUtil.getErrorMessage('NJS-004', \"queueTimeout\"));\n\n  if ((options.enableStatistics !== undefined) &&\n      (typeof options.enableStatistics !== \"boolean\"))\n    throw new Error(nodbUtil.getErrorMessage('NJS-004', \"enableStatistics\"));\n\n  if ((options.resetStatistics !== undefined) &&\n      (typeof options.resetStatistics != \"boolean\"))\n    throw new Error(nodbUtil.getErrorMessage('NJS-004', \"resetStatistics\"));\n\n  this._status = this._oracledb.POOL_STATUS_RECONFIGURING;\n  try {\n    // poolMin/poolMax/poolIncrement/poolPingInterval/poolTimeout/\n    // poolMaxPerShard/stmtCacheSize/sodaMetaDataCache parameters\n    await this._reconfigure(options);\n\n    // pool JS parameters: queueMax, queueTimeout, enableStatistics,\n    // resetStatistics\n\n    // reset the statistics-metrics only if 'resetStatistics' is true or\n    // 'enableStatistics' is being set to true\n    if (options.resetStatistics == true || (options.enableStatistics == true &&\n        this._enableStatistics == false)) {\n      this._resetStatistics();\n    }\n\n    if (options.queueMax !== undefined) {\n      this._queueMax = options.queueMax;\n    }\n\n    if (options.queueTimeout !== undefined) {\n      this._queueTimeout = options.queueTimeout;\n    }\n\n    if (options.enableStatistics !== undefined) {\n      this._enableStatistics = options.enableStatistics;\n    }\n  } finally {\n    this._status = this._oracledb.POOL_STATUS_OPEN;\n  }\n  this.emit('_checkRequestQueue');\n}\n\n\n//-----------------------------------------------------------------------------\n// close()\n//   Close the pool, optionally allowing for a period of time to pass for\n// connections to \"drain\" from the pool.\n//-----------------------------------------------------------------------------\nasync function close(a1) {\n  let drainTime = 0;\n  let forceClose = false;\n\n  // check arguments\n  nodbUtil.checkArgCount(arguments, 0, 1);\n  if (arguments.length == 1) {\n\n    // drain time must be a valid number; timeouts larger than a 32-bit signed\n    // integer are not supported\n    nodbUtil.assert(typeof a1 === 'number', 'NJS-005', 1);\n    if (a1 < 0 || isNaN(a1) || a1 > 2 ** 31) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-005', 1));\n    }\n\n    // no need to worry about drain time if no connections are out!\n    forceClose = true;\n    if (this._connectionsOut > 0) {\n      drainTime = a1 * 1000;\n    }\n\n  }\n\n  // if the pool is draining/reconfiguring/closed, throw an appropriate error\n  this._checkPoolOpen(false);\n\n  // wait for the pool to become empty or for the drain timeout to expire\n  // (whichever comes first)\n  if (drainTime > 0) {\n    this._status = this._oracledb.POOL_STATUS_DRAINING;\n    await new Promise(resolve => {\n      const timeout = setTimeout(() => {\n        this.removeAllListeners('_allCheckedIn');\n        resolve();\n      }, drainTime);\n      this.once('_allCheckedIn', () => {\n        clearTimeout(timeout);\n        resolve();\n      });\n    });\n  }\n\n  // close the pool\n  await this._close({forceClose: forceClose});\n  this._status = this._oracledb.POOL_STATUS_CLOSED;\n  this.emit('_afterPoolClose');\n\n}\n\n\n//-----------------------------------------------------------------------------\n// logStatistics()\n//  Method to print statistical related information and pool related\n//  information when enableStatistics is set to true.\n// NOTE: This function replaces the DEPRECATED _logStats() function\n//-----------------------------------------------------------------------------\nfunction logStatistics() {\n  const stats = this.getStatistics();\n  if (stats === null) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-083'));\n  }\n  stats.logStatistics();\n}\n\n\n//-----------------------------------------------------------------------------\n// getStatistics()\n//  Method to obtain a JSON object with all statistical metrics and pool\n//  properties\n//-----------------------------------------------------------------------------\nfunction getStatistics() {\n  this._checkPoolOpen(false);\n\n  if (this._enableStatistics !== true) {\n    return null;\n  }\n  return new PoolStatistics(this);\n}\n\n\n//-----------------------------------------------------------------------------\n// _setup()\n//   Sets up the pool instance with additional attributes used for logging\n// statistics and managing the connection queue.\n//-----------------------------------------------------------------------------\nfunction _setup(poolAttrs, poolAlias, oracledb) {\n  if (typeof poolAttrs.queueTimeout !== 'undefined') {\n    this._queueTimeout = poolAttrs.queueTimeout;\n  } else {\n    this._queueTimeout = oracledb.queueTimeout;\n  }\n\n  if (typeof poolAttrs.queueMax !== 'undefined') {\n    this._queueMax = poolAttrs.queueMax;\n  } else {\n    this._queueMax = oracledb.queueMax;\n  }\n\n  if (typeof poolAttrs.poolMaxPerShard !== 'undefined') {\n    this.poolMaxPerShard = poolAttrs.poolMaxPerShard;\n  }\n\n  if (typeof poolAttrs.enableStatistics !== 'undefined') {\n    this._enableStatistics = poolAttrs.enableStatistics;\n  } else {\n    this._enableStatistics = false;   // default statistics is disabled.\n  }\n\n  if (!this._enableStatistics) {\n    // DEPRECATED property _enableStats.\n    if (typeof poolAttrs._enableStats !== 'undefined') {\n      this._enableStatistics = poolAttrs._enableStats;\n    }\n  }\n\n  if (typeof poolAttrs.sessionCallback !== 'undefined') {\n    if (typeof poolAttrs.sessionCallback === 'function' ||\n        typeof poolAttrs.sessionCallback === 'string')\n      this._sessionCallback = poolAttrs.sessionCallback;\n  }\n\n  // Properties - edition, events, externalAuth - values can be set globally\n  // on oracledb and can be overridden at pool creation time.\n  if (typeof poolAttrs.edition !== 'undefined') {\n    this.edition = poolAttrs.edition;\n  } else {\n    this.edition = oracledb.edition;\n  }\n\n  if (typeof poolAttrs.events !== 'undefined') {\n    this.events = poolAttrs.events;\n  } else {\n    this.events = oracledb.events;\n  }\n\n  if (typeof poolAttrs.externalAuth !== 'undefined') {\n    this.externalAuth = poolAttrs.externalAuth;\n  } else {\n    this.externalAuth = oracledb.externalAuth;\n  }\n\n  // Properties - homogeneous, user, connectString - are NOT global properties\n  if (typeof poolAttrs.homogeneous !== 'undefined') {\n    this.homogeneous = poolAttrs.homogeneous;\n  } else {\n    this.homogeneous = true;\n  }\n  this.user = poolAttrs.user || poolAttrs.userName;\n  this.connectString = poolAttrs.connectString || poolAttrs.connectionString;\n\n  // register event handler for when request queue should be checked\n  this.on('_checkRequestQueue', this._checkRequestQueue);\n\n  // Using Object.defineProperties to add properties to the Pool instance with\n  // special properties, such as enumerable but not writable.\n  Object.defineProperties(\n    this,\n    {\n      queueMax: { // maximum number of pending pool connections that can be queued\n        enumerable: true,\n        get: function() {\n          return (this._queueMax);\n        },\n      },\n      queueTimeout: { // milliseconds a connection request can spend in queue before being failed\n        enumerable: true,\n        get: function() {\n          return (this._queueTimeout);\n        },\n      },\n      _enableStats: { // DEPRECATED. true means pool stats will be recorded\n        get: function() {\n          return (this._enableStatistics);\n        }\n      },\n      enableStatistics: { // true means pool stats will be recorded\n        enumerable: true,\n        get: function() {\n          return (this._enableStatistics);\n        }\n      },\n      _connectionsOut: { // number of connections checked out from the pool. Must be inc/dec in the main thread in JS\n        value: 0,\n        writable: true\n      },\n      _connRequestQueue: {\n        value: [],\n        writable: true\n      },\n      _status: {  // open/closing/closed\n        value: oracledb.POOL_STATUS_OPEN,\n        writable: true\n      },\n      poolAlias: {\n        enumerable: true,\n        get: function() {\n          return (poolAlias);\n        }\n      },\n      status: {  // open/closing/closed\n        enumerable: true,\n        get: function() {\n          return (this._status);\n        }\n      },\n      sessionCallback: {  // session callback\n        enumerable: true,\n        get: function() {\n          return this._sessionCallback;\n        }\n      }\n    }\n  );\n\n  this._resetStatistics();\n\n}\n\n\n//-----------------------------------------------------------------------------\n// setAccessToken()\n//   set parameters for token based authentication\n//-----------------------------------------------------------------------------\nasync function setAccessToken(options) {\n  // check arguments\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isObject(options), 'NJS-005', 1);\n  await this._setAccessToken(options);\n}\n\n\nclass Pool extends EventEmitter {\n\n  _extend(oracledb) {\n    this._oracledb = oracledb;\n    this._setup = _setup;\n    this._checkRequestQueue = _checkRequestQueue;\n    this.close = nodbUtil.callbackify(close);\n    this.getConnection = nodbUtil.callbackify(getConnection);\n    this.reconfigure = nodbUtil.callbackify(reconfigure);\n    this.setAccessToken = nodbUtil.callbackify(setAccessToken);\n    this.logStatistics = logStatistics;\n    this.getStatistics = getStatistics;\n    this.terminate = this.close;\n    this._queueMax = 0;\n    this._queueTimeout = 0;\n    this._enableStatistics = false;\n    this._timeOfReset = this._createdDate = Date.now();\n    this._sessionCallback = undefined;\n\n    // DEPRECATED alias\n    this._logStats = this.logStatistics;\n  }\n\n  // check if pool is draining/reconfiguring/closed and throw an\n  // appropriate error\n  _checkPoolOpen(ignoreReconfiguring) {\n    // if already in reconfiguring status, nothing to do.\n    if (this.status === this._oracledb.POOL_STATUS_DRAINING) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-064'));\n    } else if (this.status === this._oracledb.POOL_STATUS_CLOSED) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-065'));\n    } else if (!ignoreReconfiguring) {\n      if (this.status === this._oracledb.POOL_STATUS_RECONFIGURING) {\n        throw new Error(nodbUtil.getErrorMessage('NJS-082'));\n      }\n    }\n  }\n\n  // temporary method for determining if an object is a date until\n  // napi_is_date() can be used (when Node-API v5 can be used)\n  _isDate(val) {\n    return (util.isDate(val));\n  }\n\n  //---------------------------------------------------------------------------\n  // _resetStatistics()\n  //  To initialize the counters/timers\n  //---------------------------------------------------------------------------\n  _resetStatistics() {\n    this._timeOfReset = Date.now();\n    this._totalConnectionRequests = 0;\n    this._totalRequestsEnqueued = 0;\n    this._totalRequestsDequeued = 0;\n    this._totalFailedRequests = 0;\n    this._totalRequestsRejected = 0;\n    this._totalRequestTimeouts = 0;\n    this._maximumQueueLength = this._connRequestQueue.length;\n    this._totalTimeInQueue = 0;\n    this._minTimeInQueue = 0;\n    this._maxTimeInQueue = 0;\n  }\n\n\n  // update pool wait statistics after a connect request has spent some time in\n  // the queue\n  _updateWaitStatistics(payload) {\n    const waitTime = Date.now() - payload.enqueuedTime;\n    this._totalTimeInQueue += waitTime;\n    if (this._minTimeInQueue === 0) {\n      this._minTimeInQueue = waitTime;\n    } else {\n      this._minTimeInQueue = Math.min(this._minTimeInQueue, waitTime);\n    }\n    this._maxTimeInQueue = Math.max(this._maxTimeInQueue, waitTime);\n  }\n\n}\n\n\nmodule.exports = Pool;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/pool.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/poolStatistics.js":
/*!*****************************************************!*\
  !*** ./node_modules/oracledb/lib/poolStatistics.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright (c) 2021, 2022, Oracle and/or its affiliates.\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\n//-----------------------------------------------------------------------------\n// class PoolStatistics\n//  collection of statistics metrics for Pool object\n//-----------------------------------------------------------------------------\n\nclass PoolStatistics {\n\n  constructor(pool) {\n    let averageTimeInQueue = 0;\n\n    if (pool._totalRequestsEnqueued !== 0) {\n      averageTimeInQueue = Math.round(pool._totalTimeInQueue /\n        pool._totalRequestsEnqueued);\n    }\n\n    this.gatheredDate = Date.now ();\n    this.upTime = this.gatheredDate - pool._createdDate;\n    this.upTimeSinceReset = this.gatheredDate - pool._timeOfReset;\n    this.connectionRequests = pool._totalConnectionRequests;\n    this.requestsEnqueued = pool._totalRequestsEnqueued;\n    this.requestsDequeued = pool._totalRequestsDequeued;\n    this.failedRequests = pool._totalFailedRequests;\n    this.rejectedRequests = pool._totalRequestsRejected;\n    this.requestTimeouts = pool._totalRequestTimeouts;\n    this.maximumQueueLength = pool._maximumQueueLength;\n    this.currentQueueLength = pool._connRequestQueue.length;\n    this.timeInQueue = pool._totalTimeInQueue;\n    this.minimumTimeInQueue = pool._minTimeInQueue;\n    this.maximumTimeInQueue = pool._maxTimeInQueue;\n    this.averageTimeInQueue = averageTimeInQueue;\n    this.connectionsInUse = pool.connectionsInUse;\n    this.connectionsOpen = pool.connectionsOpen;\n    this.connectString = pool.connectString;\n    this.edition = pool.edition;\n    this.events = pool.events;\n    this.externalAuth = pool.externalAuth;\n    this.homogeneous = pool.homogeneous;\n    this.poolAlias = pool.poolAlias;\n    this.poolIncrement = pool.poolIncrement;\n    this.poolMax = pool.poolMax;\n    this.poolMaxPerShard = pool.poolMaxPerShard;\n    this.poolMin = pool.poolMin;\n    this.poolPingInterval = pool.poolPingInterval;\n    this.poolTimeout = pool.poolTimeout;\n    this.queueMax = pool.queueMax;\n    this.queueTimeout = pool.queueTimeout;\n    this.sodaMetaDataCache = pool.sodaMetaDataCache;\n    this.stmtCacheSize = pool.stmtCacheSize;\n    this.user = pool.user;\n    this.threadPoolSize = process.env.UV_THREADPOOL_SIZE;\n  }\n\n  //---------------------------------------------------------------------------\n  // logStatistics()\n  //  To print the statistics metrics of the pool\n  //---------------------------------------------------------------------------\n  logStatistics() {\n    console.log('\\nPool statistics:');\n    console.log('...gathered at:', new Date(this.gatheredDate).toISOString());\n    console.log('...up time (milliseconds):', this.upTime);\n    console.log('...up time from last reset (milliseconds)',\n      this.upTimeSinceReset);\n    console.log('...connection requests:', this.connectionRequests);\n    console.log('...requests enqueued:', this.requestsEnqueued);\n    console.log('...requests dequeued:', this.requestsDequeued);\n    console.log('...requests failed:', this.failedRequests);\n    console.log('...requests exceeding queueMax:', this.rejectedRequests);\n    console.log('...requests exceeding queueTimeout:', this.requestTimeouts);\n    console.log('...current queue length:', this.currentQueueLength);\n    console.log('...maximum queue length:', this.maximumQueueLength);\n    console.log('...sum of time in queue (milliseconds):', this.timeInQueue);\n    console.log('...minimum time in queue (milliseconds):',\n      this.minimumTimeInQueue);\n    console.log('...maximum time in queue (milliseconds):',\n      this.maximumTimeInQueue);\n    console.log('...average time in queue (milliseconds):',\n      this.averageTimeInQueue);\n    console.log('...pool connections in use:', this.connectionsInUse);\n    console.log('...pool connections open:', this.connectionsOpen);\n    console.log('Pool attributes:');\n    console.log('...connectString:', this.connectString);\n    console.log('...edition:', this.edition);\n    console.log('...events:', this.events);\n    console.log('...externalAuth:', this.externalAuth);\n    console.log('...homogeneous:', this.homogeneous);\n    console.log('...poolAlias:', this.poolAlias);\n    console.log('...poolIncrement:', this.poolIncrement);\n    console.log('...poolMax:', this.poolMax);\n    console.log('...poolMaxPerShard:', this.poolMaxPerShard);\n    console.log('...poolMin:', this.poolMin);\n    console.log('...poolPingInterval (seconds):', this.poolPingInterval);\n    console.log('...poolTimeout (seconds):', this.poolTimeout);\n    console.log('...queueMax:', this.queueMax);\n    console.log('...queueTimeout (milliseconds):', this.queueTimeout);\n    console.log('...sessionCallback:', this.sessionCallback);\n    console.log('...sodaMetaDataCache:', this.sodaMetaDataCache);\n    console.log('...stmtCacheSize:', this.stmtCacheSize);\n    console.log('...user:', this.user);\n    console.log('Related environment variables:');\n    console.log('...UV_THREADPOOL_SIZE:', this.threadPoolSize);\n  }\n}\n\nmodule.exports = PoolStatistics;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/poolStatistics.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/queryStream.js":
/*!**************************************************!*\
  !*** ./node_modules/oracledb/lib/queryStream.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2015, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst { Readable } = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\nclass QueryStream extends Readable {\n\n  constructor(rs) {\n    super({ objectMode: true });\n    this._fetching = false;\n    this._numRows = 0;\n\n    // calling open via process.nextTick to allow event handlers to be\n    // registered prior to the events being emitted\n    if (rs) {\n      process.nextTick(() => {\n        this._open(rs);\n      });\n    }\n  }\n\n  // called by readable.destroy() and ensures that the result set is closed if\n  // it has not already been closed (never called directly)\n  async _destroy(err, cb) {\n    if (this._resultSet) {\n      const rs = this._resultSet;\n      this._resultSet = null;\n      if (this._fetching) {\n        await new Promise(resolve =>\n          this.once('_doneFetching', resolve));\n      }\n      try {\n        await rs._close();\n      } catch (closeErr) {\n        cb(closeErr);\n        return;\n      }\n    }\n    cb(err);\n  }\n\n  // called when the query stream is to be associated with a result set; this\n  // takes place when the query stream if constructed (if a result set is known\n  // at that point) or by Connection.execute() when the result set is ready\n  _open(rs) {\n    this._resultSet = rs;\n\n    // trigger the event listener that may have been added in _read() now that\n    // the result set is ready\n    this.emit('open');\n\n    // emit a metadata event as a convenience to users\n    this.emit('metadata', rs.metaData);\n  }\n\n  // called by readable.read() and pushes rows to the internal queue maintained\n  // by the stream implementation (never called directly) appropriate\n  async _read() {\n\n    // still waiting on the result set to be added via _open() so add an event\n    // listener to retry when ready\n    if (!this._resultSet) {\n      this.once('open', this._read);\n      return;\n    }\n\n    // using the JS getRow() to leverage the JS row cache; the result set's\n    // _allowGetRowCall is set to true to allow the call for query streams\n    // created via ResultSet.toQueryStream()\n    try {\n      this._fetching = true;\n      this._resultSet._allowGetRowCall = true;\n      const row = await this._resultSet.getRow();\n      if (row) {\n        this.push(row);\n      } else {\n        this.push(null);\n      }\n    } catch (err) {\n      this.destroy(err);\n    } finally {\n      this._fetching = false;\n      if (this._resultSet) {\n        this._resultSet._allowGetRowCall = false;\n      } else {\n        this.emit('_doneFetching');\n      }\n    }\n  }\n\n}\n\nmodule.exports = QueryStream;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/queryStream.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/resultset.js":
/*!************************************************!*\
  !*** ./node_modules/oracledb/lib/resultset.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2016, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst QueryStream = __webpack_require__(/*! ./queryStream.js */ \"./node_modules/oracledb/lib/queryStream.js\");\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\n\n//-----------------------------------------------------------------------------\n// close()\n//   Close the result set and make it unusable for further operations.\n//-----------------------------------------------------------------------------\nasync function close() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n\n  if (this._convertedToStream) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-042'));\n  }\n\n  this._processingStarted = true;\n  await this._close();\n}\n\n\n//-----------------------------------------------------------------------------\n// getRow()\n//   Returns a single row to the caller from the result set, if one is\n// available. Rows are buffered in a JavaScript array in order to avoid trips\n// through the thread pool that would be required if implemented in C.\n//-----------------------------------------------------------------------------\nasync function getRow() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n\n  if (this._convertedToStream && !this._allowGetRowCall) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-042'));\n  }\n\n  this._allowGetRowCall = false;\n  this._processingStarted = true;\n\n  if (this._rowCache.length == 0) {\n    this._rowCache = await this._getRows(this._fetchArraySize, false, false);\n  }\n  return this._rowCache.shift();\n}\n\n\n//-----------------------------------------------------------------------------\n// getRows()\n//   Check to see if any rows are in the JS buffer (which could result from\n// interspersed calls to getRow() and getRows()). If no rows are in the buffer\n// buffer, the call is just proxied to the C layer. Otherwise, rows are pulled\n// from the buffer and potentially concatenated with rows from a call to\n// getRows().\n//-----------------------------------------------------------------------------\nasync function getRows(numRows) {\n  let rowsNeeded;\n\n  nodbUtil.checkArgCount(arguments, 0, 1);\n\n  if (arguments.length == 0) {\n    numRows = 0;\n  } else {\n    nodbUtil.assert(Number.isInteger(numRows), 'NJS-005', 1);\n    nodbUtil.assert(numRows >= 0, 'NJS-005', 1);\n  }\n\n  if (this._convertedToStream) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-042'));\n  }\n\n  this._processingStarted = true;\n\n  if (numRows == 0) {\n    let requestedRows = this._rowCache;\n\n    const fetchArraySize = this._fetchArraySize;\n    while (true) {  // eslint-disable-line\n      let rows = await this._getRows(fetchArraySize, false, false);\n      if (rows)\n        requestedRows = requestedRows.concat(rows);\n      if (rows.length < fetchArraySize)\n        break;\n    }\n    return requestedRows;\n  }\n\n  if (this._rowCache.length === 0) {\n    return await this._getRows(numRows, false, false);\n  }\n\n  rowsNeeded = numRows - this._rowCache.length;\n  if (rowsNeeded <= 0) {\n    return this._rowCache.splice(0, numRows);\n  } else {\n    const rows = await this._getRows(rowsNeeded, false, false);\n    const requestedRows = this._rowCache.concat(rows);\n    this._rowCache = [];\n    return requestedRows;\n  }\n}\n\n\nclass ResultSet {\n\n  constructor() {\n    this._rowCache = [];\n    this._processingStarted = false;\n    this._convertedToStream = false;\n    this._allowGetRowCall = false;\n    this._isActive = false;\n  }\n\n  _extend(oracledb) {\n    this._oracledb = oracledb;\n    this.close = nodbUtil.callbackify(nodbUtil.preventConcurrent(nodbUtil.serialize(close), 'NJS-017'));\n    this.getRow = nodbUtil.callbackify(nodbUtil.preventConcurrent(nodbUtil.serialize(getRow), 'NJS-017'));\n    this.getRows = nodbUtil.callbackify(nodbUtil.preventConcurrent(nodbUtil.serialize(getRows), 'NJS-017'));\n  }\n\n  _getConnection() {\n    let connection = this._parentObj;\n    while (!(connection instanceof this._oracledb.Connection))\n      connection = connection._parentObj;\n    return connection;\n  }\n\n  async _getAllRows(executeOpts, metaDataObj, isNested) {\n\n    // assign result set metadata to the object; this is either a top-level\n    // result object that is returned to the user or a metadata object for a\n    // nested cursor or empty (for implicit results which don't provide\n    // metadata to the caller)\n    if (metaDataObj && !metaDataObj.metaData) {\n      metaDataObj.metaData = this.metaData;\n    }\n\n    // determine value of maxRows to use\n    let maxRows = this._oracledb.maxRows;\n    if (executeOpts && executeOpts.maxRows !== undefined) {\n      maxRows = executeOpts.maxRows;\n    }\n\n    // determine value of outFormat to use\n    let outFormat = this._oracledb.outFormat;\n    if (executeOpts && executeOpts.outFormat !== undefined) {\n      outFormat = executeOpts.outFormat;\n    }\n\n    // determine the nested cursor indices to use, allowing for both\n    // OUT_FORMAT_ARRAY and OUT_FORMAT_OBJECT formats\n    const nestedCursorMetaDataObjs = [];\n    const nestedCursorIndices = this._nestedCursorIndices;\n    for (let i = 0; i < nestedCursorIndices.length; i++) {\n      nestedCursorMetaDataObjs[i] =\n        metaDataObj.metaData[nestedCursorIndices[i]];\n      if (outFormat == this._oracledb.OUT_FORMAT_OBJECT) {\n        nestedCursorIndices[i] = nestedCursorMetaDataObjs[i].name;\n      }\n    }\n\n    // process all rows; transform nested cursors into arrays of rows by\n    // fetching them\n    let rowsFetched = [];\n    let fetchArraySize = this._fetchArraySize;\n    let closeOnFetch = false;\n    const closeOnAllRowsFetched = !isNested && nestedCursorIndices.length === 0;\n    while (true) {    // eslint-disable-line\n      if (maxRows > 0 && fetchArraySize >= maxRows) {\n        fetchArraySize = maxRows;\n        closeOnFetch = closeOnAllRowsFetched;\n      }\n      const rows = await this._getRows(fetchArraySize, closeOnFetch,\n        closeOnAllRowsFetched);\n      if (nestedCursorIndices) {\n        for (let i = 0; i < rows.length; i++) {\n          const row = rows[i];\n          for (let j = 0; j < nestedCursorIndices.length; j++) {\n            const val = row[nestedCursorIndices[j]];\n            if (val) {\n              row[nestedCursorIndices[j]] =\n                  await val._getAllRows(executeOpts,\n                    nestedCursorMetaDataObjs[j], true);\n            }\n          }\n        }\n      }\n      if (rows) {\n        rowsFetched = rowsFetched.concat(rows);\n      }\n      if (rows.length == maxRows || rows.length < fetchArraySize) {\n        break;\n      }\n      if (maxRows > 0) {\n        maxRows -= rows.length;\n      }\n    }\n\n    // if the cursor was not automatically closed (in order to ensure that\n    // nested cursors could be fetched), close it now that all rows have been\n    // fetched\n    if (!closeOnAllRowsFetched) {\n      await this._close();\n    }\n    return rowsFetched;\n  }\n\n  _getDbObjectClassJS(schema, name) {\n    return this._connection._getDbObjectClassJS(schema, name);\n  }\n\n  [Symbol.asyncIterator]() {\n    const resultSet = this;\n    return {\n      async next() {\n        const row = await resultSet.getRow();\n        return {value: row, done: row === undefined};\n      },\n      return() {\n        return {done: true};\n      }\n    };\n  }\n\n  toQueryStream() {\n    nodbUtil.checkArgCount(arguments, 0, 0);\n\n    if (this._processingStarted) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-041'));\n    }\n\n    if (this._convertedToStream) {\n      throw new Error(nodbUtil.getErrorMessage('NJS-043'));\n    }\n\n    this._convertedToStream = true;\n\n    return new QueryStream(this);\n  }\n\n}\n\n\nmodule.exports = ResultSet;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/resultset.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/sodaCollection.js":
/*!*****************************************************!*\
  !*** ./node_modules/oracledb/lib/sodaCollection.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2018, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\n\n//-----------------------------------------------------------------------------\n// drop()\n//   Drop the collection.\n//-----------------------------------------------------------------------------\nasync function drop() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._drop();\n}\n\n\n//-----------------------------------------------------------------------------\n// insertMany()\n//   Insert an array of documents into the collection in a single round-trip.\n//-----------------------------------------------------------------------------\nasync function insertMany(docs) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(Array.isArray(docs), 'NJS-005', 1);\n\n  if (docs.length == 0) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-005', 1));\n  }\n\n  let actualDocs = Array(docs.length);\n  for (let i = 0; i < docs.length; i++) {\n    let content = docs[i];\n    if (!nodbUtil.isSodaDocument(content)) {\n      content = Buffer.from(JSON.stringify(content));\n    }\n    actualDocs[i] = content;\n  }\n\n  await this._insertMany(actualDocs);\n}\n\n\n//-----------------------------------------------------------------------------\n// insertManyAndGet()\n//   Insert an array of documents into the collection in a single round-trip\n// and return a set of result documents containing metadata.\n//-----------------------------------------------------------------------------\nasync function insertManyAndGet(docs, a2) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 1, 2);\n  nodbUtil.assert(Array.isArray(docs), 'NJS-005', 1);\n\n  if (arguments.length == 2) {\n    nodbUtil.assert(nodbUtil.isObject(a2), 'NJS-005', 2);\n    options = a2;\n  }\n\n  if (docs.length == 0) {\n    throw new Error(nodbUtil.getErrorMessage('NJS-005', 1));\n  }\n\n  let actualDocs = Array(docs.length);\n  for (let i = 0; i < docs.length; i++) {\n    let content = docs[i];\n    if (!nodbUtil.isSodaDocument(content)) {\n      content = Buffer.from(JSON.stringify(content));\n    }\n    actualDocs[i] = content;\n  }\n\n  return await this._insertManyAndGet(actualDocs, options);\n}\n\n\n//-----------------------------------------------------------------------------\n// insertOne()\n//   Inserts a single document into the collection.\n//-----------------------------------------------------------------------------\nasync function insertOne(content) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isObject(content) ||\n      nodbUtil.isSodaDocument(content), 'NJS-005', 1);\n\n  if (!nodbUtil.isSodaDocument(content)) {\n    content = Buffer.from(JSON.stringify(content));\n  }\n\n  await this._insertOne(content);\n}\n\n\n//-----------------------------------------------------------------------------\n// insertOneAndGet()\n//   Inserts a single document into the collection and returns a result\n// document containing metadata.\n//-----------------------------------------------------------------------------\nasync function insertOneAndGet(content, a2) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 1, 2);\n  nodbUtil.assert(nodbUtil.isObject(content) ||\n      nodbUtil.isSodaDocument(content), 'NJS-005', 1);\n\n  if (arguments.length == 2) {\n    nodbUtil.assert(nodbUtil.isObject(a2), 'NJS-005', 2);\n    options = a2;\n  }\n\n  if (!nodbUtil.isSodaDocument(content)) {\n    content = Buffer.from(JSON.stringify(content));\n  }\n\n  return await this._insertOneAndGet(content, options);\n}\n\n\n//-----------------------------------------------------------------------------\n// createIndex()\n//   Create an index on the collection.\n//-----------------------------------------------------------------------------\nasync function createIndex(spec) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isObject(spec), 'NJS-005', 1);\n  return await this._createIndex(JSON.stringify(spec));\n}\n\n\n//-----------------------------------------------------------------------------\n// dropIndex()\n//   Drop an index on the collection.\n//-----------------------------------------------------------------------------\nasync function dropIndex(indexName, a2) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 1, 2);\n  nodbUtil.assert(typeof indexName === 'string', 'NJS-005', 1);\n  if (arguments.length == 2) {\n    nodbUtil.assert(typeof a2 === 'object', 'NJS-005', 2);\n    options = a2;\n  }\n\n  return await this._dropIndex(indexName, options);\n}\n\n\n//-----------------------------------------------------------------------------\n// getDataGuide()\n//   Return the data guide for the collection.\n//-----------------------------------------------------------------------------\nasync function getDataGuide() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._getDataGuide();\n}\n\n\n//-----------------------------------------------------------------------------\n// save()\n//   Saves a single document into the collection.\n//-----------------------------------------------------------------------------\nasync function save(content) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isObject(content) ||\n      nodbUtil.isSodaDocument(content), 'NJS-005', 1);\n\n  if (!nodbUtil.isSodaDocument(content)) {\n    content = Buffer.from(JSON.stringify(content));\n  }\n\n  await this._save(content);\n}\n\n\n//-----------------------------------------------------------------------------\n// saveAndGet()\n//   Saves a single document into the collection and returns a result\n// document containing metadata.\n//-----------------------------------------------------------------------------\nasync function saveAndGet(content, a2) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 1, 2);\n  nodbUtil.assert(nodbUtil.isObject(content) ||\n      nodbUtil.isSodaDocument(content), 'NJS-005', 1);\n\n  if (arguments.length == 2) {\n    nodbUtil.assert(nodbUtil.isObject(a2), 'NJS-005', 2);\n    options = a2;\n  }\n\n  if (!nodbUtil.isSodaDocument(content)) {\n    content = Buffer.from(JSON.stringify(content));\n  }\n\n  return await this._saveAndGet(content, options);\n}\n\n\n//-----------------------------------------------------------------------------\n// truncate()\n//   Remove all of the documents from a collection.\n//-----------------------------------------------------------------------------\nasync function truncate() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  await this._truncate();\n}\n\n\nclass SodaCollection {\n\n  _extend() {\n    this.createIndex = nodbUtil.callbackify(nodbUtil.serialize(createIndex));\n    this.drop = nodbUtil.callbackify(nodbUtil.serialize(drop));\n    this.dropIndex = nodbUtil.callbackify(nodbUtil.serialize(dropIndex));\n    this.getDataGuide = nodbUtil.callbackify(nodbUtil.serialize(getDataGuide));\n    this.insertMany = nodbUtil.callbackify(nodbUtil.serialize(insertMany));\n    this.insertManyAndGet = nodbUtil.callbackify(nodbUtil.serialize(insertManyAndGet));\n    this.insertOne = nodbUtil.callbackify(nodbUtil.serialize(insertOne));\n    this.insertOneAndGet = nodbUtil.callbackify(nodbUtil.serialize(insertOneAndGet));\n    this.save = nodbUtil.callbackify(nodbUtil.serialize(save));\n    this.saveAndGet = nodbUtil.callbackify(nodbUtil.serialize(saveAndGet));\n    this.truncate = nodbUtil.callbackify(nodbUtil.serialize(truncate));\n  }\n\n  _getConnection() {\n    return this._database._connection;\n  }\n\n  find() {\n    nodbUtil.checkArgCount(arguments, 0, 0);\n    return this._find();\n  }\n\n  get metaData() {\n    return JSON.parse(this._metaData);\n  }\n\n}\n\nmodule.exports = SodaCollection;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/sodaCollection.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/sodaDatabase.js":
/*!***************************************************!*\
  !*** ./node_modules/oracledb/lib/sodaDatabase.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2018, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\n\n//-----------------------------------------------------------------------------\n// createCollection()\n//   Creates a SODA collection.\n//-----------------------------------------------------------------------------\nasync function createCollection(name, a2) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 1, 2);\n  nodbUtil.assert(typeof name === 'string', 'NJS-005', 1);\n\n  if (arguments.length == 2) {\n    nodbUtil.assert(nodbUtil.isObject(a2), 'NJS-005', 2);\n    options = a2;\n    if (options.metaData) {\n      if (!nodbUtil.isObject(options.metaData)) {\n        throw new Error(nodbUtil.getErrorMessage('NJS-005', 2));\n      }\n      options.metaData = JSON.stringify(options.metaData);\n    }\n  }\n\n  return await this._createCollection(name, options);\n}\n\n\n//-----------------------------------------------------------------------------\n// openCollection()\n//   Open an existing SODA collection and return it to the caller.\n//-----------------------------------------------------------------------------\nasync function openCollection(name) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(typeof name === 'string', 'NJS-005', 1);\n  return await this._openCollection(name);\n}\n\n\n//-----------------------------------------------------------------------------\n// getCollectionNames()\n//   Return an array of the names of the collections in the database.\n//-----------------------------------------------------------------------------\nasync function getCollectionNames(a1) {\n  let options = {};\n\n  nodbUtil.checkArgCount(arguments, 0, 1);\n  if (arguments.length == 1) {\n    nodbUtil.assert(nodbUtil.isObject(a1), 'NJS-005', 1);\n    options = a1;\n  }\n  return await this._getCollectionNames(options);\n}\n\n\nclass SodaDatabase {\n\n  _extend() {\n    this.createCollection = nodbUtil.callbackify(nodbUtil.serialize(createCollection));\n    this.getCollectionNames = nodbUtil.callbackify(nodbUtil.serialize(getCollectionNames));\n    this.openCollection = nodbUtil.callbackify(nodbUtil.serialize(openCollection));\n  }\n\n  _getConnection() {\n    return this._connection;\n  }\n\n  // To create a SODA document object based content and (optional) other fields\n  createDocument(content, a2) {\n    let options = {};\n\n    nodbUtil.checkArgCount(arguments, 1, 2);\n    nodbUtil.assert(Buffer.isBuffer(content) || typeof content === 'string' ||\n        nodbUtil.isObject(content), 'NJS-005', 1);\n    if (arguments.length > 1) {\n      nodbUtil.assert(nodbUtil.isObject(a2), 'NJS-005', 2);\n      options = a2;\n    }\n\n    if (typeof content === 'string') {\n      content = Buffer.from(content);\n    } else if (nodbUtil.isObject(content)) {\n      content = Buffer.from(JSON.stringify(content));\n    }\n\n    return this._createDocument(content, options);\n  }\n\n}\n\n\nmodule.exports = SodaDatabase;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/sodaDatabase.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/sodaDocCursor.js":
/*!****************************************************!*\
  !*** ./node_modules/oracledb/lib/sodaDocCursor.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2018, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\n\n//-----------------------------------------------------------------------------\n// getNext()\n//   Return the new document available from the cursor.\n//-----------------------------------------------------------------------------\nasync function getNext() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._getNext();\n}\n\n\n//-----------------------------------------------------------------------------\n// close()\n//   Close the cursor and make it unusable for further operations.\n//----------------------------------------------------------------------------\nasync function close() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  await this._close();\n}\n\n\nclass SodaDocCursor {\n\n  _extend() {\n    this.close = nodbUtil.callbackify(nodbUtil.serialize(close));\n    this.getNext = nodbUtil.callbackify(nodbUtil.serialize(getNext));\n  }\n\n  _getConnection() {\n    return this._operation._getConnection();\n  }\n\n}\n\nmodule.exports = SodaDocCursor;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/sodaDocCursor.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/sodaDocument.js":
/*!***************************************************!*\
  !*** ./node_modules/oracledb/lib/sodaDocument.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright (c) 2018, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nclass SodaDocument {\n\n  _extend() {\n    this._sodaDocumentMarker = true;\n  }\n\n  // returns the document content as a Javascript object\n  getContent() {\n    return JSON.parse(this._getContentAsString());\n  }\n\n  // returns the document content as a buffer\n  getContentAsBuffer() {\n    return this._getContentAsBuffer();\n  }\n\n  // returns the document content as a string\n  getContentAsString() {\n    return this._getContentAsString();\n  }\n\n}\n\nmodule.exports = SodaDocument;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/sodaDocument.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/sodaOperation.js":
/*!****************************************************!*\
  !*** ./node_modules/oracledb/lib/sodaOperation.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2018, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst nodbUtil = __webpack_require__(/*! ./util.js */ \"./node_modules/oracledb/lib/util.js\");\n\n//-----------------------------------------------------------------------------\n// count()\n//   Return a count of the number of documents that match the search criteria.\n//-----------------------------------------------------------------------------\nasync function count() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._count(this._options);\n}\n\n\n//-----------------------------------------------------------------------------\n// getOne()\n//   Return the first document that matches the search criteria.\n//-----------------------------------------------------------------------------\nasync function getOne() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._getOne(this._options);\n}\n\n\n//-----------------------------------------------------------------------------\n// replaceOne()\n//   Replace the first document that matches the search criteria with the\n// specified document.\n//-----------------------------------------------------------------------------\nasync function replaceOne(content) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isObject(content) ||\n      nodbUtil.isSodaDocument(content), 'NJS-005', 1);\n\n  if (!nodbUtil.isSodaDocument(content)) {\n    content = Buffer.from(JSON.stringify(content));\n  }\n\n  return await this._replaceOne(this._options, content);\n}\n\n\n//-----------------------------------------------------------------------------\n// replaceOneAndGet()\n//   Replace the first document that matches the search criteria with the\n// specified document and then return a result document containing metadata.\n//-----------------------------------------------------------------------------\nasync function replaceOneAndGet(content) {\n  nodbUtil.checkArgCount(arguments, 1, 1);\n  nodbUtil.assert(nodbUtil.isObject(content) ||\n      nodbUtil.isSodaDocument(content), 'NJS-005', 1);\n\n  if (!nodbUtil.isSodaDocument(content)) {\n    content = Buffer.from(JSON.stringify(content));\n  }\n\n  return await this._replaceOneAndGet(this._options, content);\n}\n\n\n//-----------------------------------------------------------------------------\n// remove()\n//   Remove the documents that match the search criteria from the collection\n// and return information about the operation to the caller.\n//-----------------------------------------------------------------------------\nasync function remove() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._remove(this._options);\n}\n\n\n//-----------------------------------------------------------------------------\n// getCursor()\n//   Return a cursor which will return the documents that match the search\n// criteria.\n//-----------------------------------------------------------------------------\nasync function getCursor() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._getCursor(this._options);\n}\n\n\n//-----------------------------------------------------------------------------\n// getDocuments()\n//   Return an array of documents that match the search criteria.\n//-----------------------------------------------------------------------------\nasync function getDocuments() {\n  nodbUtil.checkArgCount(arguments, 0, 0);\n  return await this._getDocuments(this._options);\n}\n\n\nclass SodaOperation {\n\n  constructor() {\n    this._options = {};\n  }\n\n  _extend() {\n    this.count = nodbUtil.callbackify(nodbUtil.serialize(count));\n    this.getCursor = nodbUtil.callbackify(nodbUtil.serialize(getCursor));\n    this.getDocuments = nodbUtil.callbackify(nodbUtil.serialize(getDocuments));\n    this.getOne = nodbUtil.callbackify(nodbUtil.serialize(getOne));\n    this.remove = nodbUtil.callbackify(nodbUtil.serialize(remove));\n    this.replaceOne = nodbUtil.callbackify(nodbUtil.serialize(replaceOne));\n    this.replaceOneAndGet = nodbUtil.callbackify(nodbUtil.serialize(replaceOneAndGet));\n  }\n\n  _getConnection() {\n    return this._collection._database._connection;\n  }\n\n  // fetchArraySize - a non-terminal function that can chain further\n  fetchArraySize(n) {\n    nodbUtil.checkArgCount(arguments, 1, 1);\n    nodbUtil.assert(typeof n === 'number', 'NJS-005', 1);\n    this._options.fetchArraySize = n;\n    return this;\n  }\n\n  // filter property - a non-terminal function and can chain further\n  filter(f) {\n    nodbUtil.checkArgCount (arguments, 1, 1);\n    nodbUtil.assert(nodbUtil.isObject(f), 'NJS-005', 1);\n    this._options.filter = JSON.stringify(f);\n    return this;\n  }\n\n  // hint - a non-terminal function and can chain further\n  hint(val) {\n    nodbUtil.checkArgCount(arguments, 1, 1);\n    nodbUtil.assert(typeof val === 'string', 'NJS-005', 1);\n    this._options.hint = val;\n    return this;\n  }\n\n  // key - a non-terminal function and can chain further\n  key(k) {\n    nodbUtil.checkArgCount(arguments, 1, 1);\n    nodbUtil.assert(typeof k === 'string', 'NJS-005', 1);\n    this._options.key = k;\n    this._options.keys = undefined;\n    return this;\n  }\n\n  // keys - a non-terminal function and can chain further\n  keys(arr) {\n    nodbUtil.checkArgCount(arguments, 1, 1);\n    nodbUtil.assert(Array.isArray(arr), 'NJS-005', 1);\n\n    for (let i = 0; i < arr.length; i++) {\n      nodbUtil.assert(typeof arr[i] === 'string', 'NJS-005', 1);\n    }\n\n    this._options.keys = arr;\n    this._options.key = undefined;\n    return this;\n  }\n\n  // limit property - a non-terminal function and can chain further\n  limit(n) {\n    nodbUtil.checkArgCount(arguments, 1, 1);\n    nodbUtil.assert(typeof n === 'number', 'NJS-005', 1);\n    this._options.limit = n;\n    return this;\n  }\n\n  // skip property - a non-terminal function and can chain further\n  skip(n) {\n    nodbUtil.checkArgCount(arguments, 1, 1);\n    nodbUtil.assert(typeof n === 'number', 'NJS-005', 1);\n    this._options.skip = n;\n    return this;\n  }\n\n  // version property - a non-terminal function and can chain further\n  version(v) {\n    nodbUtil.checkArgCount(arguments, 1, 1);\n    nodbUtil.assert(typeof v === 'string', 'NJS-005', 1);\n    this._options.version = v;\n    return this;\n  }\n\n}\n\n\nmodule.exports = SodaOperation;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/sodaOperation.js?");

/***/ }),

/***/ "./node_modules/oracledb/lib/util.js":
/*!*******************************************!*\
  !*** ./node_modules/oracledb/lib/util.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2016, 2022, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// You may not use the identified files except in compliance with the Apache\n// License, Version 2.0 (the \"License.\")\n//\n// You may obtain a copy of the License at\n// http://www.apache.org/licenses/LICENSE-2.0.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n\n\nconst util = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'util'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n// node-oracledb version number\nlet packageJSON;\ntry {\n  packageJSON = __webpack_require__(/*! ../package.json */ \"./node_modules/oracledb/package.json\");\n} catch (err) {\n  throw new Error('package.json is missing');\n}\nconst PACKAGE_JSON_VERSION = packageJSON.version;\nmodule.exports.PACKAGE_JSON_VERSION = PACKAGE_JSON_VERSION;\n\n// Directory containing the node-oracledb add-on binary\nconst RELEASE_DIR = 'build/Release';\nmodule.exports.RELEASE_DIR = RELEASE_DIR;\n\n// The default node-oracledb add-on binary filename for this Node.js\nconst BINARY_FILE = 'oracledb-' + PACKAGE_JSON_VERSION + '-' + process.platform + '-' + process.arch + '.node';\nmodule.exports.BINARY_FILE = BINARY_FILE;\n\n// Staging directory used by maintainers building the npm package\nconst STAGING_DIR = 'package/Staging';\nmodule.exports.STAGING_DIR = STAGING_DIR;\n\n// errorMessages is for NJS error messages used in the JavaScript layer\nconst errorMessages = {\n  'NJS-002': 'NJS-002: invalid pool',\n  'NJS-004': 'NJS-004: invalid value for property %s',\n  'NJS-005': 'NJS-005: invalid value for parameter %d',\n  'NJS-009': 'NJS-009: invalid number of parameters',\n  'NJS-017': 'NJS-017: concurrent operations on ResultSet are not allowed',\n  'NJS-023': 'NJS-023: concurrent operations on LOB are not allowed',\n  'NJS-037': 'NJS-037: incompatible type of value provided',\n  'NJS-040': 'NJS-040: connection request timeout. Request exceeded queueTimeout of %d',\n  'NJS-041': 'NJS-041: cannot convert ResultSet to QueryStream after invoking methods',\n  'NJS-042': 'NJS-042: cannot invoke ResultSet methods after converting to QueryStream',\n  'NJS-043': 'NJS-043: ResultSet already converted to QueryStream',\n  'NJS-045': 'NJS-045: cannot load a node-oracledb binary for Node.js ' + process.versions.node + ' (' + process.platform + ' ' + process.arch + ') %s',\n  'NJS-046': 'NJS-046: poolAlias \"%s\" already exists in the connection pool cache',\n  'NJS-047': 'NJS-047: poolAlias \"%s\" not found in the connection pool cache',\n  'NJS-064': 'NJS-064: connection pool is closing',\n  'NJS-065': 'NJS-065: connection pool was closed',\n  'NJS-067': 'NJS-067: a pre-built node-oracledb binary was not found for %s',\n  'NJS-069': 'NJS-069: node-oracledb %s requires Node.js %s or later',\n  'NJS-076': 'NJS-076: connection request rejected. Pool queue length queueMax %d reached',\n  'NJS-081': 'NJS-081: concurrent operations on a connection are disabled',\n  'NJS-082': 'NJS-082: connection pool is being reconfigured',\n  'NJS-083': 'NJS-083: pool statistics not enabled',\n  'NJS-084': 'NJS-084: invalid access token',\n  'NJS-085': 'NJS-085: invalid connection pool configuration with token based authentication. The homogeneous and externalAuth attributes must be set to true',\n  'NJS-086': 'NJS-086: invalid standalone configuration with token based authentication. The externalAuth attribute must be set to true',\n  'NJS-087': 'NJS-087: access token has expired',\n  'NJS-088': 'NJS-088: accessTokenCallback cannot be specified when accessToken is a function'\n};\n\n// getInstallURL returns a string with installation URL\nfunction getInstallURL() {\n  return ('Node-oracledb installation instructions: https://oracle.github.io/node-oracledb/INSTALL.html');\n}\n\nmodule.exports.getInstallURL = getInstallURL;\n\n// getInstallHelp returns a string with installation usage tips that may be helpful\nfunction getInstallHelp() {\n  let arch, url;\n  let mesg = getInstallURL() + '\\n';\n  if (process.platform === 'linux') {\n    if (process.arch === 'x64') {\n      url = 'https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html\\n';\n      arch = '64-bit';\n    } else if (process.arch === 'x32') {\n      url = 'https://www.oracle.com/database/technologies/instant-client/linux-x86-32-downloads.html\\n';\n      arch = '32-bit';\n    } else {\n      url = 'https://www.oracle.com/database/technologies/instant-client.html\\n';\n      arch = process.arch;\n    }\n    mesg += 'You must have ' + arch + ' Oracle Client libraries configured with ldconfig, or in LD_LIBRARY_PATH.\\n';\n    mesg += 'If you do not have Oracle Database on this computer, then install the Instant Client Basic or Basic Light package from \\n';\n    mesg += url;\n  } else if (process.platform === 'darwin') {\n    if (process.arch === 'x64') {\n      url = 'https://www.oracle.com/database/technologies/instant-client/macos-intel-x86-downloads.html\\n';\n      arch = '64-bit';\n    } else {\n      url = 'https://www.oracle.com/database/technologies/instant-client.html\\n';\n      arch = process.arch;\n    }\n    mesg += 'You must have the ' + arch + ' Oracle Instant Client Basic or Basic Light package libraries in\\n';\n    mesg += '/usr/local/lib or set by calling oracledb.initOracleClient({libDir: \"/my/instant_client_directory\"}).\\n';\n    mesg += 'Oracle Instant Client can be downloaded from ' + url;\n  } else if (process.platform === 'win32') {\n    if (process.arch === 'x64') {\n      url = 'https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html\\n';\n      arch = '64-bit';\n    } else if (process.arch === 'x32') {\n      url = 'https://www.oracle.com/database/technologies/instant-client/microsoft-windows-32-downloads.html\\n';\n      arch = '32-bit';\n    } else {\n      url = 'https://www.oracle.com/database/technologies/instant-client.html\\n';\n      arch = process.arch;\n    }\n    mesg += 'You must have ' + arch + ' Oracle Client libraries in your PATH environment variable.\\n';\n    mesg += 'If you do not have Oracle Database on this computer, then install the Instant Client Basic or Basic Light package from\\n';\n    mesg += url;\n    mesg += 'A Microsoft Visual Studio Redistributable suitable for your Oracle client library version must be available.\\n';\n  } else {\n    url = 'https://www.oracle.com/database/technologies/instant-client.html\\n';\n    mesg += 'You must have ' + process.arch + ' Oracle Client libraries in your operating system library search path.\\n';\n    mesg += 'If you do not have Oracle Database on this computer, then install an Instant Client Basic or Basic Light package from: \\n';\n    mesg += url;\n  }\n  return mesg;\n}\n\nmodule.exports.getInstallHelp = getInstallHelp;\n\n// getErrorMessage is used to get and format error messages to make throwing\n// errors a little more convenient.\nfunction getErrorMessage(errorCode) {\n  let args = Array.prototype.slice.call(arguments);\n  args[0] = errorMessages[errorCode];\n  return util.format.apply(util, args);\n}\n\nmodule.exports.getErrorMessage = getErrorMessage;\n\n// assert is typically used at the beginning of public functions to assert\n// preconditions for the function to execute. Most commonly it is used to\n// validate the number of arguments and their types and throw an error if they\n// don't match what is expected.\nfunction assert(condition, errorCode, messageArg1) {\n  if (!condition) {\n    throw new Error(getErrorMessage(errorCode, messageArg1));\n  }\n}\n\nmodule.exports.assert = assert;\n\n// checkArgCount is used to validate the number of arguments, particularly with\n// optional parameters (range of number of parameters).  If the number of\n// arguments is not within the given range, an error is thrown.\nfunction checkArgCount(args, minArgCount, maxArgCount) {\n  if (args.length < minArgCount || args.length > maxArgCount)\n    throw new Error(getErrorMessage('NJS-009'));\n}\n\nmodule.exports.checkArgCount = checkArgCount;\n\n\n// The callbackify function is used to wrap async methods to add optional\n// callback support. If the last parameter passed to a method is a function,\n// then it is assumed that the callback pattern is being used and the promise\n// is resolved or rejected and the callback invoked; otherwise, the function is\n// called unchanged and a promise is returned\nfunction callbackify(func) {\n  const wrapper = function() {\n\n    // if last argument is not a function, simply invoke the function as usual\n    // and a promise will be returned\n    if (typeof arguments[arguments.length - 1] !== 'function') {\n      return func.apply(this, arguments).catch(function stackCapture(e) {\n        Error.captureStackTrace(e, stackCapture);\n        throw e;\n      });\n    }\n\n    // otherwise, resolve or reject the promise and invoke the callback\n    const args = Array.prototype.slice.call(arguments, 0, arguments.length - 1);\n    const cb = arguments[arguments.length - 1];\n    func.apply(this, args).then(function(result) {\n      cb(null, result);\n    }, cb);\n\n  };\n  if (func.name) {\n    Object.defineProperty(wrapper, 'name', { value: func.name });\n  }\n  return wrapper;\n}\n\nmodule.exports.callbackify = callbackify;\n\n// The serialize function is used to wrap methods to ensure that the connection\n// is not used concurrently by multiple threads\nfunction serialize(func) {\n  return async function() {\n\n    // determine the connection associated with the object\n    const connection = this._getConnection();\n\n    // acquire the \"lock\"; this simply checks to see if another operation is in\n    // progress, and if so, waits for it to complete\n    await connection._acquireLock();\n\n    // call the function and ensure that the lock is \"released\" once the\n    // function has completed -- either successfully or in failure\n    try {\n      return await func.apply(this, arguments);\n    } finally {\n      connection._releaseLock();\n    }\n  };\n}\n\nmodule.exports.serialize = serialize;\n\nfunction preventConcurrent(func, errorCode) {\n  return async function() {\n    if (this._isActive)\n      throw new Error(getErrorMessage(errorCode));\n    this._isActive = true;\n    try {\n      return await func.apply(this, arguments);\n    } finally {\n      this._isActive = false;\n    }\n  };\n}\n\nmodule.exports.preventConcurrent = preventConcurrent;\n\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\nmodule.exports.isObject = isObject;\n\nfunction isObjectOrArray(value) {\n  return (value !== null && typeof value === 'object') || Array.isArray(value);\n}\n\nmodule.exports.isObjectOrArray = isObjectOrArray;\n\nfunction isSodaDocument(value) {\n  return (value != null && value._sodaDocumentMarker);\n}\n\nfunction isXid(value) {\n  return (isObject(value) &&\n            (value.formatId !== undefined) &&\n            (value.globalTransactionId !== undefined) &&\n            (value.branchQualifier !== undefined));\n}\n\nmodule.exports.isXid = isXid;\n\nmodule.exports.isSodaDocument = isSodaDocument;\n\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/lib/util.js?");

/***/ }),

/***/ "./node_modules/oracledb/package.json":
/*!********************************************!*\
  !*** ./node_modules/oracledb/package.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"name\":\"oracledb\",\"version\":\"5.5.0\",\"description\":\"A Node.js module for Oracle Database access from JavaScript and TypeScript\",\"license\":\"Apache-2.0\",\"homepage\":\"http://oracle.github.io/node-oracledb/\",\"keywords\":[\"Oracle\",\"Database\",\"official\",\"DB\",\"SQL\",\"JSON\",\"PL/SQL\",\"SODA\",\"OCI\",\"API\",\"client\",\"library\",\"driver\",\"add-on\",\"extension\",\"binding\",\"interface\",\"adapter\",\"module\"],\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/oracle/node-oracledb.git\"},\"scripts\":{\"install\":\"node package/install.js\",\"prune\":\"node package/prunebinaries.js\"},\"engines\":{\"node\":\">=10.16\"},\"maintainers\":[{\"name\":\"Oracle Corp.\"}],\"bugs\":{\"url\":\"https://github.com/oracle/node-oracledb/issues\"},\"main\":\"./index.js\"}');\n\n//# sourceURL=webpack://dt/./node_modules/oracledb/package.json?");

/***/ })

}]);